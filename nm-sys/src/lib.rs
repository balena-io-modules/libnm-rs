// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal)]

extern crate libc;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gio_sys as gio;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type NM80211Mode = c_int;
pub const NM_802_11_MODE_UNKNOWN: NM80211Mode = 0;
pub const NM_802_11_MODE_ADHOC: NM80211Mode = 1;
pub const NM_802_11_MODE_INFRA: NM80211Mode = 2;
pub const NM_802_11_MODE_AP: NM80211Mode = 3;
pub const NM_802_11_MODE_MESH: NM80211Mode = 4;

pub type NMActiveConnectionState = c_int;
pub const NM_ACTIVE_CONNECTION_STATE_UNKNOWN: NMActiveConnectionState = 0;
pub const NM_ACTIVE_CONNECTION_STATE_ACTIVATING: NMActiveConnectionState = 1;
pub const NM_ACTIVE_CONNECTION_STATE_ACTIVATED: NMActiveConnectionState = 2;
pub const NM_ACTIVE_CONNECTION_STATE_DEACTIVATING: NMActiveConnectionState = 3;
pub const NM_ACTIVE_CONNECTION_STATE_DEACTIVATED: NMActiveConnectionState = 4;

pub type NMActiveConnectionStateReason = c_int;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN: NMActiveConnectionStateReason = 0;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_NONE: NMActiveConnectionStateReason = 1;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED: NMActiveConnectionStateReason = 2;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED: NMActiveConnectionStateReason = 3;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED: NMActiveConnectionStateReason = 4;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID: NMActiveConnectionStateReason = 5;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT: NMActiveConnectionStateReason = 6;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT: NMActiveConnectionStateReason = 7;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED: NMActiveConnectionStateReason = 8;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS: NMActiveConnectionStateReason = 9;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED: NMActiveConnectionStateReason = 10;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED: NMActiveConnectionStateReason = 11;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED: NMActiveConnectionStateReason = 12;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED: NMActiveConnectionStateReason = 13;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED: NMActiveConnectionStateReason = 14;

pub type NMAgentManagerError = c_int;
pub const NM_AGENT_MANAGER_ERROR_FAILED: NMAgentManagerError = 0;
pub const NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED: NMAgentManagerError = 1;
pub const NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER: NMAgentManagerError = 2;
pub const NM_AGENT_MANAGER_ERROR_NOT_REGISTERED: NMAgentManagerError = 3;
pub const NM_AGENT_MANAGER_ERROR_NO_SECRETS: NMAgentManagerError = 4;
pub const NM_AGENT_MANAGER_ERROR_USER_CANCELED: NMAgentManagerError = 5;

pub type NMCapability = c_int;
pub const NM_CAPABILITY_TEAM: NMCapability = 1;
pub const NM_CAPABILITY_OVS: NMCapability = 2;

pub type NMClientError = c_int;
pub const NM_CLIENT_ERROR_FAILED: NMClientError = 0;
pub const NM_CLIENT_ERROR_MANAGER_NOT_RUNNING: NMClientError = 1;
pub const NM_CLIENT_ERROR_OBJECT_CREATION_FAILED: NMClientError = 2;

pub type NMClientPermission = c_int;
pub const NM_CLIENT_PERMISSION_NONE: NMClientPermission = 0;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK: NMClientPermission = 1;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI: NMClientPermission = 2;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN: NMClientPermission = 3;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX: NMClientPermission = 4;
pub const NM_CLIENT_PERMISSION_SLEEP_WAKE: NMClientPermission = 5;
pub const NM_CLIENT_PERMISSION_NETWORK_CONTROL: NMClientPermission = 6;
pub const NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED: NMClientPermission = 7;
pub const NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN: NMClientPermission = 8;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM: NMClientPermission = 9;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN: NMClientPermission = 10;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME: NMClientPermission = 11;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS: NMClientPermission = 12;
pub const NM_CLIENT_PERMISSION_RELOAD: NMClientPermission = 13;
pub const NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK: NMClientPermission = 14;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS: NMClientPermission = 15;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK: NMClientPermission = 16;
pub const NM_CLIENT_PERMISSION_WIFI_SCAN: NMClientPermission = 17;

pub type NMClientPermissionResult = c_int;
pub const NM_CLIENT_PERMISSION_RESULT_UNKNOWN: NMClientPermissionResult = 0;
pub const NM_CLIENT_PERMISSION_RESULT_YES: NMClientPermissionResult = 1;
pub const NM_CLIENT_PERMISSION_RESULT_AUTH: NMClientPermissionResult = 2;
pub const NM_CLIENT_PERMISSION_RESULT_NO: NMClientPermissionResult = 3;

pub type NMConnectionError = c_int;
pub const NM_CONNECTION_ERROR_FAILED: NMConnectionError = 0;
pub const NM_CONNECTION_ERROR_SETTING_NOT_FOUND: NMConnectionError = 1;
pub const NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND: NMConnectionError = 2;
pub const NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET: NMConnectionError = 3;
pub const NM_CONNECTION_ERROR_MISSING_SETTING: NMConnectionError = 4;
pub const NM_CONNECTION_ERROR_INVALID_SETTING: NMConnectionError = 5;
pub const NM_CONNECTION_ERROR_MISSING_PROPERTY: NMConnectionError = 6;
pub const NM_CONNECTION_ERROR_INVALID_PROPERTY: NMConnectionError = 7;

pub type NMConnectionMultiConnect = c_int;
pub const NM_CONNECTION_MULTI_CONNECT_DEFAULT: NMConnectionMultiConnect = 0;
pub const NM_CONNECTION_MULTI_CONNECT_SINGLE: NMConnectionMultiConnect = 1;
pub const NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE: NMConnectionMultiConnect = 2;
pub const NM_CONNECTION_MULTI_CONNECT_MULTIPLE: NMConnectionMultiConnect = 3;

pub type NMConnectivityState = c_int;
pub const NM_CONNECTIVITY_UNKNOWN: NMConnectivityState = 0;
pub const NM_CONNECTIVITY_NONE: NMConnectivityState = 1;
pub const NM_CONNECTIVITY_PORTAL: NMConnectivityState = 2;
pub const NM_CONNECTIVITY_LIMITED: NMConnectivityState = 3;
pub const NM_CONNECTIVITY_FULL: NMConnectivityState = 4;

pub type NMCryptoError = c_int;
pub const NM_CRYPTO_ERROR_FAILED: NMCryptoError = 0;
pub const NM_CRYPTO_ERROR_INVALID_DATA: NMCryptoError = 1;
pub const NM_CRYPTO_ERROR_INVALID_PASSWORD: NMCryptoError = 2;
pub const NM_CRYPTO_ERROR_UNKNOWN_CIPHER: NMCryptoError = 3;
pub const NM_CRYPTO_ERROR_DECRYPTION_FAILED: NMCryptoError = 4;
pub const NM_CRYPTO_ERROR_ENCRYPTION_FAILED: NMCryptoError = 5;

pub type NMDeviceError = c_int;
pub const NM_DEVICE_ERROR_FAILED: NMDeviceError = 0;
pub const NM_DEVICE_ERROR_CREATION_FAILED: NMDeviceError = 1;
pub const NM_DEVICE_ERROR_INVALID_CONNECTION: NMDeviceError = 2;
pub const NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION: NMDeviceError = 3;
pub const NM_DEVICE_ERROR_NOT_ACTIVE: NMDeviceError = 4;
pub const NM_DEVICE_ERROR_NOT_SOFTWARE: NMDeviceError = 5;
pub const NM_DEVICE_ERROR_NOT_ALLOWED: NMDeviceError = 6;
pub const NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND: NMDeviceError = 7;
pub const NM_DEVICE_ERROR_VERSION_ID_MISMATCH: NMDeviceError = 8;
pub const NM_DEVICE_ERROR_MISSING_DEPENDENCIES: NMDeviceError = 9;
pub const NM_DEVICE_ERROR_INVALID_ARGUMENT: NMDeviceError = 10;

pub type NMDeviceState = c_int;
pub const NM_DEVICE_STATE_UNKNOWN: NMDeviceState = 0;
pub const NM_DEVICE_STATE_UNMANAGED: NMDeviceState = 10;
pub const NM_DEVICE_STATE_UNAVAILABLE: NMDeviceState = 20;
pub const NM_DEVICE_STATE_DISCONNECTED: NMDeviceState = 30;
pub const NM_DEVICE_STATE_PREPARE: NMDeviceState = 40;
pub const NM_DEVICE_STATE_CONFIG: NMDeviceState = 50;
pub const NM_DEVICE_STATE_NEED_AUTH: NMDeviceState = 60;
pub const NM_DEVICE_STATE_IP_CONFIG: NMDeviceState = 70;
pub const NM_DEVICE_STATE_IP_CHECK: NMDeviceState = 80;
pub const NM_DEVICE_STATE_SECONDARIES: NMDeviceState = 90;
pub const NM_DEVICE_STATE_ACTIVATED: NMDeviceState = 100;
pub const NM_DEVICE_STATE_DEACTIVATING: NMDeviceState = 110;
pub const NM_DEVICE_STATE_FAILED: NMDeviceState = 120;

pub type NMDeviceStateReason = c_int;
pub const NM_DEVICE_STATE_REASON_NONE: NMDeviceStateReason = 0;
pub const NM_DEVICE_STATE_REASON_UNKNOWN: NMDeviceStateReason = 1;
pub const NM_DEVICE_STATE_REASON_NOW_MANAGED: NMDeviceStateReason = 2;
pub const NM_DEVICE_STATE_REASON_NOW_UNMANAGED: NMDeviceStateReason = 3;
pub const NM_DEVICE_STATE_REASON_CONFIG_FAILED: NMDeviceStateReason = 4;
pub const NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE: NMDeviceStateReason = 5;
pub const NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED: NMDeviceStateReason = 6;
pub const NM_DEVICE_STATE_REASON_NO_SECRETS: NMDeviceStateReason = 7;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT: NMDeviceStateReason = 8;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED: NMDeviceStateReason = 9;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED: NMDeviceStateReason = 10;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT: NMDeviceStateReason = 11;
pub const NM_DEVICE_STATE_REASON_PPP_START_FAILED: NMDeviceStateReason = 12;
pub const NM_DEVICE_STATE_REASON_PPP_DISCONNECT: NMDeviceStateReason = 13;
pub const NM_DEVICE_STATE_REASON_PPP_FAILED: NMDeviceStateReason = 14;
pub const NM_DEVICE_STATE_REASON_DHCP_START_FAILED: NMDeviceStateReason = 15;
pub const NM_DEVICE_STATE_REASON_DHCP_ERROR: NMDeviceStateReason = 16;
pub const NM_DEVICE_STATE_REASON_DHCP_FAILED: NMDeviceStateReason = 17;
pub const NM_DEVICE_STATE_REASON_SHARED_START_FAILED: NMDeviceStateReason = 18;
pub const NM_DEVICE_STATE_REASON_SHARED_FAILED: NMDeviceStateReason = 19;
pub const NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED: NMDeviceStateReason = 20;
pub const NM_DEVICE_STATE_REASON_AUTOIP_ERROR: NMDeviceStateReason = 21;
pub const NM_DEVICE_STATE_REASON_AUTOIP_FAILED: NMDeviceStateReason = 22;
pub const NM_DEVICE_STATE_REASON_MODEM_BUSY: NMDeviceStateReason = 23;
pub const NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE: NMDeviceStateReason = 24;
pub const NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER: NMDeviceStateReason = 25;
pub const NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT: NMDeviceStateReason = 26;
pub const NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED: NMDeviceStateReason = 27;
pub const NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED: NMDeviceStateReason = 28;
pub const NM_DEVICE_STATE_REASON_GSM_APN_FAILED: NMDeviceStateReason = 29;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING: NMDeviceStateReason = 30;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED: NMDeviceStateReason = 31;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT: NMDeviceStateReason = 32;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED: NMDeviceStateReason = 33;
pub const NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED: NMDeviceStateReason = 34;
pub const NM_DEVICE_STATE_REASON_FIRMWARE_MISSING: NMDeviceStateReason = 35;
pub const NM_DEVICE_STATE_REASON_REMOVED: NMDeviceStateReason = 36;
pub const NM_DEVICE_STATE_REASON_SLEEPING: NMDeviceStateReason = 37;
pub const NM_DEVICE_STATE_REASON_CONNECTION_REMOVED: NMDeviceStateReason = 38;
pub const NM_DEVICE_STATE_REASON_USER_REQUESTED: NMDeviceStateReason = 39;
pub const NM_DEVICE_STATE_REASON_CARRIER: NMDeviceStateReason = 40;
pub const NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED: NMDeviceStateReason = 41;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE: NMDeviceStateReason = 42;
pub const NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND: NMDeviceStateReason = 43;
pub const NM_DEVICE_STATE_REASON_BT_FAILED: NMDeviceStateReason = 44;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED: NMDeviceStateReason = 45;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED: NMDeviceStateReason = 46;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED: NMDeviceStateReason = 47;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_WRONG: NMDeviceStateReason = 48;
pub const NM_DEVICE_STATE_REASON_INFINIBAND_MODE: NMDeviceStateReason = 49;
pub const NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED: NMDeviceStateReason = 50;
pub const NM_DEVICE_STATE_REASON_BR2684_FAILED: NMDeviceStateReason = 51;
pub const NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE: NMDeviceStateReason = 52;
pub const NM_DEVICE_STATE_REASON_SSID_NOT_FOUND: NMDeviceStateReason = 53;
pub const NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED: NMDeviceStateReason = 54;
pub const NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED: NMDeviceStateReason = 55;
pub const NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED: NMDeviceStateReason = 56;
pub const NM_DEVICE_STATE_REASON_MODEM_FAILED: NMDeviceStateReason = 57;
pub const NM_DEVICE_STATE_REASON_MODEM_AVAILABLE: NMDeviceStateReason = 58;
pub const NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT: NMDeviceStateReason = 59;
pub const NM_DEVICE_STATE_REASON_NEW_ACTIVATION: NMDeviceStateReason = 60;
pub const NM_DEVICE_STATE_REASON_PARENT_CHANGED: NMDeviceStateReason = 61;
pub const NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED: NMDeviceStateReason = 62;
pub const NM_DEVICE_STATE_REASON_OVSDB_FAILED: NMDeviceStateReason = 63;
pub const NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE: NMDeviceStateReason = 64;
pub const NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED: NMDeviceStateReason = 65;
pub const NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED: NMDeviceStateReason = 66;
pub const NM_DEVICE_STATE_REASON_PEER_NOT_FOUND: NMDeviceStateReason = 67;

pub type NMDeviceType = c_int;
pub const NM_DEVICE_TYPE_UNKNOWN: NMDeviceType = 0;
pub const NM_DEVICE_TYPE_ETHERNET: NMDeviceType = 1;
pub const NM_DEVICE_TYPE_WIFI: NMDeviceType = 2;
pub const NM_DEVICE_TYPE_UNUSED1: NMDeviceType = 3;
pub const NM_DEVICE_TYPE_UNUSED2: NMDeviceType = 4;
pub const NM_DEVICE_TYPE_BT: NMDeviceType = 5;
pub const NM_DEVICE_TYPE_OLPC_MESH: NMDeviceType = 6;
pub const NM_DEVICE_TYPE_WIMAX: NMDeviceType = 7;
pub const NM_DEVICE_TYPE_MODEM: NMDeviceType = 8;
pub const NM_DEVICE_TYPE_INFINIBAND: NMDeviceType = 9;
pub const NM_DEVICE_TYPE_BOND: NMDeviceType = 10;
pub const NM_DEVICE_TYPE_VLAN: NMDeviceType = 11;
pub const NM_DEVICE_TYPE_ADSL: NMDeviceType = 12;
pub const NM_DEVICE_TYPE_BRIDGE: NMDeviceType = 13;
pub const NM_DEVICE_TYPE_GENERIC: NMDeviceType = 14;
pub const NM_DEVICE_TYPE_TEAM: NMDeviceType = 15;
pub const NM_DEVICE_TYPE_TUN: NMDeviceType = 16;
pub const NM_DEVICE_TYPE_IP_TUNNEL: NMDeviceType = 17;
pub const NM_DEVICE_TYPE_MACVLAN: NMDeviceType = 18;
pub const NM_DEVICE_TYPE_VXLAN: NMDeviceType = 19;
pub const NM_DEVICE_TYPE_VETH: NMDeviceType = 20;
pub const NM_DEVICE_TYPE_MACSEC: NMDeviceType = 21;
pub const NM_DEVICE_TYPE_DUMMY: NMDeviceType = 22;
pub const NM_DEVICE_TYPE_PPP: NMDeviceType = 23;
pub const NM_DEVICE_TYPE_OVS_INTERFACE: NMDeviceType = 24;
pub const NM_DEVICE_TYPE_OVS_PORT: NMDeviceType = 25;
pub const NM_DEVICE_TYPE_OVS_BRIDGE: NMDeviceType = 26;
pub const NM_DEVICE_TYPE_WPAN: NMDeviceType = 27;
pub const NM_DEVICE_TYPE_6LOWPAN: NMDeviceType = 28;
pub const NM_DEVICE_TYPE_WIREGUARD: NMDeviceType = 29;
pub const NM_DEVICE_TYPE_WIFI_P2P: NMDeviceType = 30;
pub const NM_DEVICE_TYPE_VRF: NMDeviceType = 31;

pub type NMIPTunnelMode = c_int;
pub const NM_IP_TUNNEL_MODE_UNKNOWN: NMIPTunnelMode = 0;
pub const NM_IP_TUNNEL_MODE_IPIP: NMIPTunnelMode = 1;
pub const NM_IP_TUNNEL_MODE_GRE: NMIPTunnelMode = 2;
pub const NM_IP_TUNNEL_MODE_SIT: NMIPTunnelMode = 3;
pub const NM_IP_TUNNEL_MODE_ISATAP: NMIPTunnelMode = 4;
pub const NM_IP_TUNNEL_MODE_VTI: NMIPTunnelMode = 5;
pub const NM_IP_TUNNEL_MODE_IP6IP6: NMIPTunnelMode = 6;
pub const NM_IP_TUNNEL_MODE_IPIP6: NMIPTunnelMode = 7;
pub const NM_IP_TUNNEL_MODE_IP6GRE: NMIPTunnelMode = 8;
pub const NM_IP_TUNNEL_MODE_VTI6: NMIPTunnelMode = 9;
pub const NM_IP_TUNNEL_MODE_GRETAP: NMIPTunnelMode = 10;
pub const NM_IP_TUNNEL_MODE_IP6GRETAP: NMIPTunnelMode = 11;

pub type NMManagerError = c_int;
pub const NM_MANAGER_ERROR_FAILED: NMManagerError = 0;
pub const NM_MANAGER_ERROR_PERMISSION_DENIED: NMManagerError = 1;
pub const NM_MANAGER_ERROR_UNKNOWN_CONNECTION: NMManagerError = 2;
pub const NM_MANAGER_ERROR_UNKNOWN_DEVICE: NMManagerError = 3;
pub const NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE: NMManagerError = 4;
pub const NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE: NMManagerError = 5;
pub const NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE: NMManagerError = 6;
pub const NM_MANAGER_ERROR_DEPENDENCY_FAILED: NMManagerError = 7;
pub const NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE: NMManagerError = 8;
pub const NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED: NMManagerError = 9;
pub const NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL: NMManagerError = 10;
pub const NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN: NMManagerError = 11;
pub const NM_MANAGER_ERROR_INVALID_ARGUMENTS: NMManagerError = 12;
pub const NM_MANAGER_ERROR_MISSING_PLUGIN: NMManagerError = 13;

pub type NMMetered = c_int;
pub const NM_METERED_UNKNOWN: NMMetered = 0;
pub const NM_METERED_YES: NMMetered = 1;
pub const NM_METERED_NO: NMMetered = 2;
pub const NM_METERED_GUESS_YES: NMMetered = 3;
pub const NM_METERED_GUESS_NO: NMMetered = 4;

pub type NMRollbackResult = c_int;
pub const NM_ROLLBACK_RESULT_OK: NMRollbackResult = 0;
pub const NM_ROLLBACK_RESULT_ERR_NO_DEVICE: NMRollbackResult = 1;
pub const NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED: NMRollbackResult = 2;
pub const NM_ROLLBACK_RESULT_ERR_FAILED: NMRollbackResult = 3;

pub type NMSecretAgentError = c_int;
pub const NM_SECRET_AGENT_ERROR_FAILED: NMSecretAgentError = 0;
pub const NM_SECRET_AGENT_ERROR_PERMISSION_DENIED: NMSecretAgentError = 1;
pub const NM_SECRET_AGENT_ERROR_INVALID_CONNECTION: NMSecretAgentError = 2;
pub const NM_SECRET_AGENT_ERROR_USER_CANCELED: NMSecretAgentError = 3;
pub const NM_SECRET_AGENT_ERROR_AGENT_CANCELED: NMSecretAgentError = 4;
pub const NM_SECRET_AGENT_ERROR_NO_SECRETS: NMSecretAgentError = 5;

pub type NMSetting8021xCKFormat = c_int;
pub const NM_SETTING_802_1X_CK_FORMAT_UNKNOWN: NMSetting8021xCKFormat = 0;
pub const NM_SETTING_802_1X_CK_FORMAT_X509: NMSetting8021xCKFormat = 1;
pub const NM_SETTING_802_1X_CK_FORMAT_RAW_KEY: NMSetting8021xCKFormat = 2;
pub const NM_SETTING_802_1X_CK_FORMAT_PKCS12: NMSetting8021xCKFormat = 3;

pub type NMSetting8021xCKScheme = c_int;
pub const NM_SETTING_802_1X_CK_SCHEME_UNKNOWN: NMSetting8021xCKScheme = 0;
pub const NM_SETTING_802_1X_CK_SCHEME_BLOB: NMSetting8021xCKScheme = 1;
pub const NM_SETTING_802_1X_CK_SCHEME_PATH: NMSetting8021xCKScheme = 2;
pub const NM_SETTING_802_1X_CK_SCHEME_PKCS11: NMSetting8021xCKScheme = 3;

pub type NMSettingCompareFlags = c_int;
pub const NM_SETTING_COMPARE_FLAG_EXACT: NMSettingCompareFlags = 0;
pub const NM_SETTING_COMPARE_FLAG_FUZZY: NMSettingCompareFlags = 1;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_ID: NMSettingCompareFlags = 2;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS: NMSettingCompareFlags = 4;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS: NMSettingCompareFlags = 8;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS: NMSettingCompareFlags = 16;
pub const NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT: NMSettingCompareFlags = 32;
pub const NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT: NMSettingCompareFlags = 64;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP: NMSettingCompareFlags = 128;

pub type NMSettingConnectionAutoconnectSlaves = c_int;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT: NMSettingConnectionAutoconnectSlaves = -1;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO: NMSettingConnectionAutoconnectSlaves = 0;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES: NMSettingConnectionAutoconnectSlaves = 1;

pub type NMSettingConnectionLldp = c_int;
pub const NM_SETTING_CONNECTION_LLDP_DEFAULT: NMSettingConnectionLldp = -1;
pub const NM_SETTING_CONNECTION_LLDP_DISABLE: NMSettingConnectionLldp = 0;
pub const NM_SETTING_CONNECTION_LLDP_ENABLE_RX: NMSettingConnectionLldp = 1;

pub type NMSettingConnectionLlmnr = c_int;
pub const NM_SETTING_CONNECTION_LLMNR_DEFAULT: NMSettingConnectionLlmnr = -1;
pub const NM_SETTING_CONNECTION_LLMNR_NO: NMSettingConnectionLlmnr = 0;
pub const NM_SETTING_CONNECTION_LLMNR_RESOLVE: NMSettingConnectionLlmnr = 1;
pub const NM_SETTING_CONNECTION_LLMNR_YES: NMSettingConnectionLlmnr = 2;

pub type NMSettingConnectionMdns = c_int;
pub const NM_SETTING_CONNECTION_MDNS_DEFAULT: NMSettingConnectionMdns = -1;
pub const NM_SETTING_CONNECTION_MDNS_NO: NMSettingConnectionMdns = 0;
pub const NM_SETTING_CONNECTION_MDNS_RESOLVE: NMSettingConnectionMdns = 1;
pub const NM_SETTING_CONNECTION_MDNS_YES: NMSettingConnectionMdns = 2;

pub type NMSettingDiffResult = c_int;
pub const NM_SETTING_DIFF_RESULT_UNKNOWN: NMSettingDiffResult = 0;
pub const NM_SETTING_DIFF_RESULT_IN_A: NMSettingDiffResult = 1;
pub const NM_SETTING_DIFF_RESULT_IN_B: NMSettingDiffResult = 2;
pub const NM_SETTING_DIFF_RESULT_IN_A_DEFAULT: NMSettingDiffResult = 4;
pub const NM_SETTING_DIFF_RESULT_IN_B_DEFAULT: NMSettingDiffResult = 8;

pub type NMSettingIP6ConfigAddrGenMode = c_int;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64: NMSettingIP6ConfigAddrGenMode = 0;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY: NMSettingIP6ConfigAddrGenMode = 1;

pub type NMSettingIP6ConfigPrivacy = c_int;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN: NMSettingIP6ConfigPrivacy = -1;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED: NMSettingIP6ConfigPrivacy = 0;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR: NMSettingIP6ConfigPrivacy = 1;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR: NMSettingIP6ConfigPrivacy = 2;

pub type NMSettingMacRandomization = c_int;
pub const NM_SETTING_MAC_RANDOMIZATION_DEFAULT: NMSettingMacRandomization = 0;
pub const NM_SETTING_MAC_RANDOMIZATION_NEVER: NMSettingMacRandomization = 1;
pub const NM_SETTING_MAC_RANDOMIZATION_ALWAYS: NMSettingMacRandomization = 2;

pub type NMSettingMacsecMode = c_int;
pub const NM_SETTING_MACSEC_MODE_PSK: NMSettingMacsecMode = 0;
pub const NM_SETTING_MACSEC_MODE_EAP: NMSettingMacsecMode = 1;

pub type NMSettingMacsecValidation = c_int;
pub const NM_SETTING_MACSEC_VALIDATION_DISABLE: NMSettingMacsecValidation = 0;
pub const NM_SETTING_MACSEC_VALIDATION_CHECK: NMSettingMacsecValidation = 1;
pub const NM_SETTING_MACSEC_VALIDATION_STRICT: NMSettingMacsecValidation = 2;

pub type NMSettingMacvlanMode = c_int;
pub const NM_SETTING_MACVLAN_MODE_UNKNOWN: NMSettingMacvlanMode = 0;
pub const NM_SETTING_MACVLAN_MODE_VEPA: NMSettingMacvlanMode = 1;
pub const NM_SETTING_MACVLAN_MODE_BRIDGE: NMSettingMacvlanMode = 2;
pub const NM_SETTING_MACVLAN_MODE_PRIVATE: NMSettingMacvlanMode = 3;
pub const NM_SETTING_MACVLAN_MODE_PASSTHRU: NMSettingMacvlanMode = 4;
pub const NM_SETTING_MACVLAN_MODE_SOURCE: NMSettingMacvlanMode = 5;

pub type NMSettingProxyMethod = c_int;
pub const NM_SETTING_PROXY_METHOD_NONE: NMSettingProxyMethod = 0;
pub const NM_SETTING_PROXY_METHOD_AUTO: NMSettingProxyMethod = 1;

pub type NMSettingSerialParity = c_int;
pub const NM_SETTING_SERIAL_PARITY_NONE: NMSettingSerialParity = 0;
pub const NM_SETTING_SERIAL_PARITY_EVEN: NMSettingSerialParity = 1;
pub const NM_SETTING_SERIAL_PARITY_ODD: NMSettingSerialParity = 2;

pub type NMSettingTunMode = c_int;
pub const NM_SETTING_TUN_MODE_UNKNOWN: NMSettingTunMode = 0;
pub const NM_SETTING_TUN_MODE_TUN: NMSettingTunMode = 1;
pub const NM_SETTING_TUN_MODE_TAP: NMSettingTunMode = 2;

pub type NMSettingWirelessPowersave = c_int;
pub const NM_SETTING_WIRELESS_POWERSAVE_DEFAULT: NMSettingWirelessPowersave = 0;
pub const NM_SETTING_WIRELESS_POWERSAVE_IGNORE: NMSettingWirelessPowersave = 1;
pub const NM_SETTING_WIRELESS_POWERSAVE_DISABLE: NMSettingWirelessPowersave = 2;
pub const NM_SETTING_WIRELESS_POWERSAVE_ENABLE: NMSettingWirelessPowersave = 3;

pub type NMSettingWirelessSecurityFils = c_int;
pub const NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT: NMSettingWirelessSecurityFils = 0;
pub const NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE: NMSettingWirelessSecurityFils = 1;
pub const NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL: NMSettingWirelessSecurityFils = 2;
pub const NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED: NMSettingWirelessSecurityFils = 3;

pub type NMSettingWirelessSecurityPmf = c_int;
pub const NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT: NMSettingWirelessSecurityPmf = 0;
pub const NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE: NMSettingWirelessSecurityPmf = 1;
pub const NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL: NMSettingWirelessSecurityPmf = 2;
pub const NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED: NMSettingWirelessSecurityPmf = 3;

pub type NMSettingsError = c_int;
pub const NM_SETTINGS_ERROR_FAILED: NMSettingsError = 0;
pub const NM_SETTINGS_ERROR_PERMISSION_DENIED: NMSettingsError = 1;
pub const NM_SETTINGS_ERROR_NOT_SUPPORTED: NMSettingsError = 2;
pub const NM_SETTINGS_ERROR_INVALID_CONNECTION: NMSettingsError = 3;
pub const NM_SETTINGS_ERROR_READ_ONLY_CONNECTION: NMSettingsError = 4;
pub const NM_SETTINGS_ERROR_UUID_EXISTS: NMSettingsError = 5;
pub const NM_SETTINGS_ERROR_INVALID_HOSTNAME: NMSettingsError = 6;
pub const NM_SETTINGS_ERROR_INVALID_ARGUMENTS: NMSettingsError = 7;

pub type NMSriovVFVlanProtocol = c_int;
pub const NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q: NMSriovVFVlanProtocol = 0;
pub const NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD: NMSriovVFVlanProtocol = 1;

pub type NMState = c_int;
pub const NM_STATE_UNKNOWN: NMState = 0;
pub const NM_STATE_ASLEEP: NMState = 10;
pub const NM_STATE_DISCONNECTED: NMState = 20;
pub const NM_STATE_DISCONNECTING: NMState = 30;
pub const NM_STATE_CONNECTING: NMState = 40;
pub const NM_STATE_CONNECTED_LOCAL: NMState = 50;
pub const NM_STATE_CONNECTED_SITE: NMState = 60;
pub const NM_STATE_CONNECTED_GLOBAL: NMState = 70;

pub type NMTernary = c_int;
pub const NM_TERNARY_DEFAULT: NMTernary = -1;
pub const NM_TERNARY_FALSE: NMTernary = 0;
pub const NM_TERNARY_TRUE: NMTernary = 1;

pub type NMUtilsSecurityType = c_int;
pub const NMU_SEC_INVALID: NMUtilsSecurityType = 0;
pub const NMU_SEC_NONE: NMUtilsSecurityType = 1;
pub const NMU_SEC_STATIC_WEP: NMUtilsSecurityType = 2;
pub const NMU_SEC_LEAP: NMUtilsSecurityType = 3;
pub const NMU_SEC_DYNAMIC_WEP: NMUtilsSecurityType = 4;
pub const NMU_SEC_WPA_PSK: NMUtilsSecurityType = 5;
pub const NMU_SEC_WPA_ENTERPRISE: NMUtilsSecurityType = 6;
pub const NMU_SEC_WPA2_PSK: NMUtilsSecurityType = 7;
pub const NMU_SEC_WPA2_ENTERPRISE: NMUtilsSecurityType = 8;
pub const NMU_SEC_SAE: NMUtilsSecurityType = 9;
pub const NMU_SEC_OWE: NMUtilsSecurityType = 10;

pub type NMVlanPriorityMap = c_int;
pub const NM_VLAN_INGRESS_MAP: NMVlanPriorityMap = 0;
pub const NM_VLAN_EGRESS_MAP: NMVlanPriorityMap = 1;

pub type NMVpnConnectionState = c_int;
pub const NM_VPN_CONNECTION_STATE_UNKNOWN: NMVpnConnectionState = 0;
pub const NM_VPN_CONNECTION_STATE_PREPARE: NMVpnConnectionState = 1;
pub const NM_VPN_CONNECTION_STATE_NEED_AUTH: NMVpnConnectionState = 2;
pub const NM_VPN_CONNECTION_STATE_CONNECT: NMVpnConnectionState = 3;
pub const NM_VPN_CONNECTION_STATE_IP_CONFIG_GET: NMVpnConnectionState = 4;
pub const NM_VPN_CONNECTION_STATE_ACTIVATED: NMVpnConnectionState = 5;
pub const NM_VPN_CONNECTION_STATE_FAILED: NMVpnConnectionState = 6;
pub const NM_VPN_CONNECTION_STATE_DISCONNECTED: NMVpnConnectionState = 7;

pub type NMVpnConnectionStateReason = c_int;
pub const NM_VPN_CONNECTION_STATE_REASON_UNKNOWN: NMVpnConnectionStateReason = 0;
pub const NM_VPN_CONNECTION_STATE_REASON_NONE: NMVpnConnectionStateReason = 1;
pub const NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED: NMVpnConnectionStateReason = 2;
pub const NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED: NMVpnConnectionStateReason = 3;
pub const NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED: NMVpnConnectionStateReason = 4;
pub const NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID: NMVpnConnectionStateReason = 5;
pub const NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT: NMVpnConnectionStateReason = 6;
pub const NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT: NMVpnConnectionStateReason = 7;
pub const NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED: NMVpnConnectionStateReason = 8;
pub const NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS: NMVpnConnectionStateReason = 9;
pub const NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED: NMVpnConnectionStateReason = 10;
pub const NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED: NMVpnConnectionStateReason = 11;

pub type NMVpnPluginError = c_int;
pub const NM_VPN_PLUGIN_ERROR_FAILED: NMVpnPluginError = 0;
pub const NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS: NMVpnPluginError = 1;
pub const NM_VPN_PLUGIN_ERROR_ALREADY_STARTED: NMVpnPluginError = 2;
pub const NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS: NMVpnPluginError = 3;
pub const NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED: NMVpnPluginError = 4;
pub const NM_VPN_PLUGIN_ERROR_WRONG_STATE: NMVpnPluginError = 5;
pub const NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS: NMVpnPluginError = 6;
pub const NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED: NMVpnPluginError = 7;
pub const NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION: NMVpnPluginError = 8;
pub const NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED: NMVpnPluginError = 9;

pub type NMVpnPluginFailure = c_int;
pub const NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED: NMVpnPluginFailure = 0;
pub const NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED: NMVpnPluginFailure = 1;
pub const NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG: NMVpnPluginFailure = 2;

pub type NMVpnServiceState = c_int;
pub const NM_VPN_SERVICE_STATE_UNKNOWN: NMVpnServiceState = 0;
pub const NM_VPN_SERVICE_STATE_INIT: NMVpnServiceState = 1;
pub const NM_VPN_SERVICE_STATE_SHUTDOWN: NMVpnServiceState = 2;
pub const NM_VPN_SERVICE_STATE_STARTING: NMVpnServiceState = 3;
pub const NM_VPN_SERVICE_STATE_STARTED: NMVpnServiceState = 4;
pub const NM_VPN_SERVICE_STATE_STOPPING: NMVpnServiceState = 5;
pub const NM_VPN_SERVICE_STATE_STOPPED: NMVpnServiceState = 6;

pub type NMWepKeyType = c_int;
pub const NM_WEP_KEY_TYPE_UNKNOWN: NMWepKeyType = 0;
pub const NM_WEP_KEY_TYPE_KEY: NMWepKeyType = 1;
pub const NM_WEP_KEY_TYPE_PASSPHRASE: NMWepKeyType = 2;

pub type NMWimaxNspNetworkType = c_int;
pub const NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN: NMWimaxNspNetworkType = 0;
pub const NM_WIMAX_NSP_NETWORK_TYPE_HOME: NMWimaxNspNetworkType = 1;
pub const NM_WIMAX_NSP_NETWORK_TYPE_PARTNER: NMWimaxNspNetworkType = 2;
pub const NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER: NMWimaxNspNetworkType = 3;

// Constants
pub const NM_ACCESS_POINT_BSSID: *const c_char = b"bssid\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_FLAGS: *const c_char = b"flags\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_FREQUENCY: *const c_char = b"frequency\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_LAST_SEEN: *const c_char = b"last-seen\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_MAX_BITRATE: *const c_char = b"max-bitrate\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_RSN_FLAGS: *const c_char = b"rsn-flags\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_SSID: *const c_char = b"ssid\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_STRENGTH: *const c_char = b"strength\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_WPA_FLAGS: *const c_char = b"wpa-flags\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_CONNECTION: *const c_char = b"connection\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DEFAULT: *const c_char = b"default\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DEFAULT6: *const c_char = b"default6\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DEVICES: *const c_char = b"devices\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DHCP4_CONFIG: *const c_char = b"dhcp4-config\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DHCP6_CONFIG: *const c_char = b"dhcp6-config\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_IP4_CONFIG: *const c_char = b"ip4-config\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_IP6_CONFIG: *const c_char = b"ip6-config\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_MASTER: *const c_char = b"master\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_SPECIFIC_OBJECT_PATH: *const c_char = b"specific-object-path\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_STATE_FLAGS: *const c_char = b"state-flags\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_TYPE: *const c_char = b"type\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_UUID: *const c_char = b"uuid\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_VPN: *const c_char = b"vpn\0" as *const u8 as *const c_char;
pub const NM_BRIDGE_VLAN_VID_MAX: c_int = 4094;
pub const NM_BRIDGE_VLAN_VID_MIN: c_int = 1;
pub const NM_CHECKPOINT_CREATED: *const c_char = b"created\0" as *const u8 as *const c_char;
pub const NM_CHECKPOINT_DEVICES: *const c_char = b"devices\0" as *const u8 as *const c_char;
pub const NM_CHECKPOINT_ROLLBACK_TIMEOUT: *const c_char = b"rollback-timeout\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ACTIVATING_CONNECTION: *const c_char = b"activating-connection\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ACTIVE_CONNECTIONS: *const c_char = b"active-connections\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ACTIVE_CONNECTION_ADDED: *const c_char = b"active-connection-added\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ACTIVE_CONNECTION_REMOVED: *const c_char = b"active-connection-removed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ALL_DEVICES: *const c_char = b"all-devices\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ANY_DEVICE_ADDED: *const c_char = b"any-device-added\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ANY_DEVICE_REMOVED: *const c_char = b"any-device-removed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CAN_MODIFY: *const c_char = b"can-modify\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CAPABILITIES: *const c_char = b"capabilities\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CHECKPOINTS: *const c_char = b"checkpoints\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTIONS: *const c_char = b"connections\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTION_ADDED: *const c_char = b"connection-added\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTION_REMOVED: *const c_char = b"connection-removed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTIVITY: *const c_char = b"connectivity\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTIVITY_CHECK_AVAILABLE: *const c_char = b"connectivity-check-available\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTIVITY_CHECK_ENABLED: *const c_char = b"connectivity-check-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTIVITY_CHECK_URI: *const c_char = b"connectivity-check-uri\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DBUS_CONNECTION: *const c_char = b"dbus-connection\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DBUS_NAME_OWNER: *const c_char = b"dbus-name-owner\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DEVICES: *const c_char = b"devices\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DEVICE_ADDED: *const c_char = b"device-added\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DEVICE_REMOVED: *const c_char = b"device-removed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DNS_CONFIGURATION: *const c_char = b"dns-configuration\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DNS_MODE: *const c_char = b"dns-mode\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DNS_RC_MANAGER: *const c_char = b"dns-rc-manager\0" as *const u8 as *const c_char;
pub const NM_CLIENT_HOSTNAME: *const c_char = b"hostname\0" as *const u8 as *const c_char;
pub const NM_CLIENT_INSTANCE_FLAGS: *const c_char = b"instance-flags\0" as *const u8 as *const c_char;
pub const NM_CLIENT_METERED: *const c_char = b"metered\0" as *const u8 as *const c_char;
pub const NM_CLIENT_NETWORKING_ENABLED: *const c_char = b"networking-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_NM_RUNNING: *const c_char = b"nm-running\0" as *const u8 as *const c_char;
pub const NM_CLIENT_PERMISSIONS_STATE: *const c_char = b"permissions-state\0" as *const u8 as *const c_char;
pub const NM_CLIENT_PERMISSION_CHANGED: *const c_char = b"permission-changed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_PRIMARY_CONNECTION: *const c_char = b"primary-connection\0" as *const u8 as *const c_char;
pub const NM_CLIENT_STARTUP: *const c_char = b"startup\0" as *const u8 as *const c_char;
pub const NM_CLIENT_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_CLIENT_VERSION: *const c_char = b"version\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WIMAX_ENABLED: *const c_char = b"wimax-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WIMAX_HARDWARE_ENABLED: *const c_char = b"wimax-hardware-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WIRELESS_ENABLED: *const c_char = b"wireless-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WIRELESS_HARDWARE_ENABLED: *const c_char = b"wireless-hardware-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WWAN_ENABLED: *const c_char = b"wwan-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WWAN_HARDWARE_ENABLED: *const c_char = b"wwan-hardware-enabled\0" as *const u8 as *const c_char;
pub const NM_CONNECTION_CHANGED: *const c_char = b"changed\0" as *const u8 as *const c_char;
pub const NM_CONNECTION_NORMALIZE_PARAM_IP6_CONFIG_METHOD: *const c_char = b"ip6-config-method\0" as *const u8 as *const c_char;
pub const NM_CONNECTION_SECRETS_CLEARED: *const c_char = b"secrets-cleared\0" as *const u8 as *const c_char;
pub const NM_CONNECTION_SECRETS_UPDATED: *const c_char = b"secrets-updated\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE: *const c_char = b"org.freedesktop.NetworkManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_DNS_MANAGER: *const c_char = b"org.freedesktop.NetworkManager.DnsManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_SETTINGS: *const c_char = b"org.freedesktop.NetworkManager.Settings\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_SETTINGS_CONNECTION: *const c_char = b"org.freedesktop.NetworkManager.Settings.Connection\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_SETTINGS_CONNECTION_SECRETS: *const c_char = b"org.freedesktop.NetworkManager.Settings.Connection.Secrets\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_VPN: *const c_char = b"org.freedesktop.NetworkManager.VPN.Manager\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_VPN_CONNECTION: *const c_char = b"org.freedesktop.NetworkManager.VPN.Connection\0" as *const u8 as *const c_char;
pub const NM_DBUS_INVALID_VPN_CONNECTION: *const c_char = b"org.freedesktop.NetworkManager.VPNConnections.InvalidVPNConnection\0" as *const u8 as *const c_char;
pub const NM_DBUS_NO_ACTIVE_VPN_CONNECTION: *const c_char = b"org.freedesktop.NetworkManager.VPNConnections.NoActiveVPNConnection\0" as *const u8 as *const c_char;
pub const NM_DBUS_NO_VPN_CONNECTIONS: *const c_char = b"org.freedesktop.NetworkManager.VPNConnections.NoVPNConnections\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH: *const c_char = b"/org/freedesktop/NetworkManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_AGENT_MANAGER: *const c_char = b"/org/freedesktop/NetworkManager/AgentManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_DNS_MANAGER: *const c_char = b"/org/freedesktop/NetworkManager/DnsManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_SECRET_AGENT: *const c_char = b"/org/freedesktop/NetworkManager/SecretAgent\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_SETTINGS: *const c_char = b"/org/freedesktop/NetworkManager/Settings\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_SETTINGS_CONNECTION: *const c_char = b"/org/freedesktop/NetworkManager/Settings/Connection\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_VPN: *const c_char = b"/org/freedesktop/NetworkManager/VPN/Manager\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_VPN_CONNECTION: *const c_char = b"/org/freedesktop/NetworkManager/VPN/Connection\0" as *const u8 as *const c_char;
pub const NM_DBUS_SERVICE: *const c_char = b"org.freedesktop.NetworkManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_ALREADY_STARTED: *const c_char = b"AlreadyStarted\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_ALREADY_STOPPED: *const c_char = b"AlreadyStopped\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_BAD_ARGUMENTS: *const c_char = b"BadArguments\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_ERROR_PREFIX: *const c_char = b"org.freedesktop.NetworkManager.VPN.Error\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_INTERACTIVE_NOT_SUPPORTED: *const c_char = b"InteractiveNotSupported\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_CONNECT_FAILED: *const c_char = b"ConnectFailed\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_IP4_CONFIG: *const c_char = b"IP4Config\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_IP_CONFIG_BAD: *const c_char = b"IPConfigBad\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_LAUNCH_FAILED: *const c_char = b"LaunchFailed\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_LOGIN_BANNER: *const c_char = b"LoginBanner\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_LOGIN_FAILED: *const c_char = b"LoginFailed\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_STATE_CHANGE: *const c_char = b"StateChange\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_VPN_CONFIG_BAD: *const c_char = b"VPNConfigBad\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_STARTING_IN_PROGRESS: *const c_char = b"StartingInProgress\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_STOPPING_IN_PROGRESS: *const c_char = b"StoppingInProgress\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_WRONG_STATE: *const c_char = b"WrongState\0" as *const u8 as *const c_char;
pub const NM_DEVICE_6LOWPAN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_6LOWPAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ACTIVE_CONNECTION: *const c_char = b"active-connection\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ADSL_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_AUTOCONNECT: *const c_char = b"autoconnect\0" as *const u8 as *const c_char;
pub const NM_DEVICE_AVAILABLE_CONNECTIONS: *const c_char = b"available-connections\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BOND_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BOND_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BOND_SLAVES: *const c_char = b"slaves\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BRIDGE_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BRIDGE_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BRIDGE_SLAVES: *const c_char = b"slaves\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BT_CAPABILITIES: *const c_char = b"bt-capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BT_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BT_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_DEVICE_CAPABILITIES: *const c_char = b"capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DEVICE_TYPE: *const c_char = b"device-type\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DHCP4_CONFIG: *const c_char = b"dhcp4-config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DHCP6_CONFIG: *const c_char = b"dhcp6-config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DRIVER: *const c_char = b"driver\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DRIVER_VERSION: *const c_char = b"driver-version\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DUMMY_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_PERMANENT_HW_ADDRESS: *const c_char = b"perm-hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_S390_SUBCHANNELS: *const c_char = b"s390-subchannels\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_SPEED: *const c_char = b"speed\0" as *const u8 as *const c_char;
pub const NM_DEVICE_FIRMWARE_MISSING: *const c_char = b"firmware-missing\0" as *const u8 as *const c_char;
pub const NM_DEVICE_FIRMWARE_VERSION: *const c_char = b"firmware-version\0" as *const u8 as *const c_char;
pub const NM_DEVICE_GENERIC_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_GENERIC_TYPE_DESCRIPTION: *const c_char = b"type-description\0" as *const u8 as *const c_char;
pub const NM_DEVICE_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_INFINIBAND_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_INFINIBAND_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_INTERFACE: *const c_char = b"interface\0" as *const u8 as *const c_char;
pub const NM_DEVICE_INTERFACE_FLAGS: *const c_char = b"interface-flags\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP4_CONFIG: *const c_char = b"ip4-config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP4_CONNECTIVITY: *const c_char = b"ip4-connectivity\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP6_CONFIG: *const c_char = b"ip6-config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP6_CONNECTIVITY: *const c_char = b"ip6-connectivity\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_INTERFACE: *const c_char = b"ip-interface\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_ENCAPSULATION_LIMIT: *const c_char = b"encapsulation-limit\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_FLAGS: *const c_char = b"flags\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_FLOW_LABEL: *const c_char = b"flow-label\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_INPUT_KEY: *const c_char = b"input-key\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_LOCAL: *const c_char = b"local\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_OUTPUT_KEY: *const c_char = b"output-key\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_PATH_MTU_DISCOVERY: *const c_char = b"path-mtu-discovery\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_REMOTE: *const c_char = b"remote\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_TTL: *const c_char = b"ttl\0" as *const u8 as *const c_char;
pub const NM_DEVICE_LLDP_NEIGHBORS: *const c_char = b"lldp-neighbors\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_CIPHER_SUITE: *const c_char = b"cipher-suite\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_ENCODING_SA: *const c_char = b"encoding-sa\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_ENCRYPT: *const c_char = b"encrypt\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_ES: *const c_char = b"es\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_ICV_LENGTH: *const c_char = b"icv-length\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_INCLUDE_SCI: *const c_char = b"include-sci\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_PROTECT: *const c_char = b"protect\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_REPLAY_PROTECT: *const c_char = b"replay-protect\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_SCB: *const c_char = b"scb\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_SCI: *const c_char = b"sci\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_VALIDATION: *const c_char = b"validation\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_WINDOW: *const c_char = b"window\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_NO_PROMISC: *const c_char = b"no-promisc\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_TAP: *const c_char = b"tap\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MANAGED: *const c_char = b"managed\0" as *const u8 as *const c_char;
pub const NM_DEVICE_METERED: *const c_char = b"metered\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MODEM_APN: *const c_char = b"apn\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MODEM_CURRENT_CAPABILITIES: *const c_char = b"current-capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MODEM_DEVICE_ID: *const c_char = b"device-id\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MODEM_MODEM_CAPABILITIES: *const c_char = b"modem-capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MODEM_OPERATOR_CODE: *const c_char = b"operator-code\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_DEVICE_NM_PLUGIN_MISSING: *const c_char = b"nm-plugin-missing\0" as *const u8 as *const c_char;
pub const NM_DEVICE_OLPC_MESH_ACTIVE_CHANNEL: *const c_char = b"active-channel\0" as *const u8 as *const c_char;
pub const NM_DEVICE_OLPC_MESH_COMPANION: *const c_char = b"companion\0" as *const u8 as *const c_char;
pub const NM_DEVICE_OLPC_MESH_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_OVS_BRIDGE_SLAVES: *const c_char = b"slaves\0" as *const u8 as *const c_char;
pub const NM_DEVICE_OVS_PORT_SLAVES: *const c_char = b"slaves\0" as *const u8 as *const c_char;
pub const NM_DEVICE_PHYSICAL_PORT_ID: *const c_char = b"physical-port-id\0" as *const u8 as *const c_char;
pub const NM_DEVICE_PRODUCT: *const c_char = b"product\0" as *const u8 as *const c_char;
pub const NM_DEVICE_REAL: *const c_char = b"real\0" as *const u8 as *const c_char;
pub const NM_DEVICE_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_DEVICE_STATE_REASON: *const c_char = b"state-reason\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TEAM_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TEAM_CONFIG: *const c_char = b"config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TEAM_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TEAM_SLAVES: *const c_char = b"slaves\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_GROUP: *const c_char = b"group\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_MULTI_QUEUE: *const c_char = b"multi-queue\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_NO_PI: *const c_char = b"no-pi\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_OWNER: *const c_char = b"owner\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_VNET_HDR: *const c_char = b"vnet-hdr\0" as *const u8 as *const c_char;
pub const NM_DEVICE_UDI: *const c_char = b"udi\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VENDOR: *const c_char = b"vendor\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VLAN_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VLAN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VLAN_VLAN_ID: *const c_char = b"vlan-id\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VRF_TABLE: *const c_char = b"table\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_AGEING: *const c_char = b"ageing\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_DST_PORT: *const c_char = b"dst-port\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_GROUP: *const c_char = b"group\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_L2MISS: *const c_char = b"l2miss\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_L3MISS: *const c_char = b"l3miss\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_LEARNING: *const c_char = b"learning\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_LIMIT: *const c_char = b"limit\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_LOCAL: *const c_char = b"local\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_PROXY: *const c_char = b"proxy\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_RSC: *const c_char = b"rsc\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_SRC_PORT_MAX: *const c_char = b"src-port-max\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_SRC_PORT_MIN: *const c_char = b"src-port-min\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_TTL: *const c_char = b"ttl\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_ACCESS_POINTS: *const c_char = b"access-points\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_ACTIVE_ACCESS_POINT: *const c_char = b"active-access-point\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_BITRATE: *const c_char = b"bitrate\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_CAPABILITIES: *const c_char = b"wireless-capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_LAST_SCAN: *const c_char = b"last-scan\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_P2P_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_P2P_PEERS: *const c_char = b"peers\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_P2P_WFDIES: *const c_char = b"wfdies\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_PERMANENT_HW_ADDRESS: *const c_char = b"perm-hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_ACTIVE_NSP: *const c_char = b"active-nsp\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_BSID: *const c_char = b"bsid\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_CENTER_FREQUENCY: *const c_char = b"center-frequency\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_CINR: *const c_char = b"cinr\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_NSPS: *const c_char = b"nsps\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_RSSI: *const c_char = b"rssi\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_TX_POWER: *const c_char = b"tx-power\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIREGUARD_FWMARK: *const c_char = b"fwmark\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIREGUARD_LISTEN_PORT: *const c_char = b"listen-port\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIREGUARD_PUBLIC_KEY: *const c_char = b"public-key\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WPAN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DHCP_CONFIG_FAMILY: *const c_char = b"family\0" as *const u8 as *const c_char;
pub const NM_DHCP_CONFIG_OPTIONS: *const c_char = b"options\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_ESP_HW_OFFLOAD: *const c_char = b"feature-esp-hw-offload\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_ESP_TX_CSUM_HW_OFFLOAD: *const c_char = b"feature-esp-tx-csum-hw-offload\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_FCOE_MTU: *const c_char = b"feature-fcoe-mtu\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_GRO: *const c_char = b"feature-gro\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_GSO: *const c_char = b"feature-gso\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_HIGHDMA: *const c_char = b"feature-highdma\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_HW_TC_OFFLOAD: *const c_char = b"feature-hw-tc-offload\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_L2_FWD_OFFLOAD: *const c_char = b"feature-l2-fwd-offload\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_LOOPBACK: *const c_char = b"feature-loopback\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_LRO: *const c_char = b"feature-lro\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_NTUPLE: *const c_char = b"feature-ntuple\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX: *const c_char = b"feature-rx\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RXHASH: *const c_char = b"feature-rxhash\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RXVLAN: *const c_char = b"feature-rxvlan\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_ALL: *const c_char = b"feature-rx-all\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_FCS: *const c_char = b"feature-rx-fcs\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_GRO_HW: *const c_char = b"feature-rx-gro-hw\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_UDP_TUNNEL_PORT_OFFLOAD: *const c_char = b"feature-rx-udp_tunnel-port-offload\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_VLAN_FILTER: *const c_char = b"feature-rx-vlan-filter\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_VLAN_STAG_FILTER: *const c_char = b"feature-rx-vlan-stag-filter\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_RX_VLAN_STAG_HW_PARSE: *const c_char = b"feature-rx-vlan-stag-hw-parse\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_SG: *const c_char = b"feature-sg\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TLS_HW_RECORD: *const c_char = b"feature-tls-hw-record\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TLS_HW_TX_OFFLOAD: *const c_char = b"feature-tls-hw-tx-offload\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TSO: *const c_char = b"feature-tso\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX: *const c_char = b"feature-tx\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TXVLAN: *const c_char = b"feature-txvlan\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_FCOE_CRC: *const c_char = b"feature-tx-checksum-fcoe-crc\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IPV4: *const c_char = b"feature-tx-checksum-ipv4\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IPV6: *const c_char = b"feature-tx-checksum-ipv6\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IP_GENERIC: *const c_char = b"feature-tx-checksum-ip-generic\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_SCTP: *const c_char = b"feature-tx-checksum-sctp\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_ESP_SEGMENTATION: *const c_char = b"feature-tx-esp-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_FCOE_SEGMENTATION: *const c_char = b"feature-tx-fcoe-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GRE_CSUM_SEGMENTATION: *const c_char = b"feature-tx-gre-csum-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GRE_SEGMENTATION: *const c_char = b"feature-tx-gre-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GSO_PARTIAL: *const c_char = b"feature-tx-gso-partial\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_GSO_ROBUST: *const c_char = b"feature-tx-gso-robust\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_IPXIP4_SEGMENTATION: *const c_char = b"feature-tx-ipxip4-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_IPXIP6_SEGMENTATION: *const c_char = b"feature-tx-ipxip6-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_NOCACHE_COPY: *const c_char = b"feature-tx-nocache-copy\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_SCATTER_GATHER: *const c_char = b"feature-tx-scatter-gather\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_SCATTER_GATHER_FRAGLIST: *const c_char = b"feature-tx-scatter-gather-fraglist\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_SCTP_SEGMENTATION: *const c_char = b"feature-tx-sctp-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP6_SEGMENTATION: *const c_char = b"feature-tx-tcp6-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP_ECN_SEGMENTATION: *const c_char = b"feature-tx-tcp-ecn-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP_MANGLEID_SEGMENTATION: *const c_char = b"feature-tx-tcp-mangleid-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_TCP_SEGMENTATION: *const c_char = b"feature-tx-tcp-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_UDP_SEGMENTATION: *const c_char = b"feature-tx-udp-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_UDP_TNL_CSUM_SEGMENTATION: *const c_char = b"feature-tx-udp_tnl-csum-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_UDP_TNL_SEGMENTATION: *const c_char = b"feature-tx-udp_tnl-segmentation\0" as *const u8 as *const c_char;
pub const NM_ETHTOOL_OPTNAME_FEATURE_TX_VLAN_STAG_HW_INSERT: *const c_char = b"feature-tx-vlan-stag-hw-insert\0" as *const u8 as *const c_char;
pub const NM_IP_ADDRESS_ATTRIBUTE_LABEL: *const c_char = b"label\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_ADDRESSES: *const c_char = b"addresses\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_DOMAINS: *const c_char = b"domains\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_FAMILY: *const c_char = b"family\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_GATEWAY: *const c_char = b"gateway\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_NAMESERVERS: *const c_char = b"nameservers\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_ROUTES: *const c_char = b"routes\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_SEARCHES: *const c_char = b"searches\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_WINS_SERVERS: *const c_char = b"wins-servers\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_CWND: *const c_char = b"cwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_FROM: *const c_char = b"from\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_INITCWND: *const c_char = b"initcwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_INITRWND: *const c_char = b"initrwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND: *const c_char = b"lock-cwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_INITCWND: *const c_char = b"lock-initcwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_INITRWND: *const c_char = b"lock-initrwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU: *const c_char = b"lock-mtu\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_WINDOW: *const c_char = b"lock-window\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_ONLINK: *const c_char = b"onlink\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_SCOPE: *const c_char = b"scope\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_SRC: *const c_char = b"src\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_TABLE: *const c_char = b"table\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_WINDOW: *const c_char = b"window\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_CHASSIS_ID: *const c_char = b"chassis-id\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_CHASSIS_ID_TYPE: *const c_char = b"chassis-id-type\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_DESTINATION: *const c_char = b"destination\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_PPVID: *const c_char = b"ieee-802-1-ppvid\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_PPVIDS: *const c_char = b"ieee-802-1-ppvids\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_PPVID_FLAGS: *const c_char = b"ieee-802-1-ppvid-flags\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_PVID: *const c_char = b"ieee-802-1-pvid\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_VID: *const c_char = b"ieee-802-1-vid\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_VLANS: *const c_char = b"ieee-802-1-vlans\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_VLAN_NAME: *const c_char = b"ieee-802-1-vlan-name\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_3_MAC_PHY_CONF: *const c_char = b"ieee-802-3-mac-phy-conf\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_3_MAX_FRAME_SIZE: *const c_char = b"ieee-802-3-max-frame-size\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_3_POWER_VIA_MDI: *const c_char = b"ieee-802-3-power-via-mdi\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_MANAGEMENT_ADDRESSES: *const c_char = b"management-addresses\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_PORT_DESCRIPTION: *const c_char = b"port-description\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_PORT_ID: *const c_char = b"port-id\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_PORT_ID_TYPE: *const c_char = b"port-id-type\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_SYSTEM_CAPABILITIES: *const c_char = b"system-capabilities\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_SYSTEM_DESCRIPTION: *const c_char = b"system-description\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_SYSTEM_NAME: *const c_char = b"system-name\0" as *const u8 as *const c_char;
pub const NM_LLDP_DEST_NEAREST_BRIDGE: *const c_char = b"nearest-bridge\0" as *const u8 as *const c_char;
pub const NM_LLDP_DEST_NEAREST_CUSTOMER_BRIDGE: *const c_char = b"nearest-customer-bridge\0" as *const u8 as *const c_char;
pub const NM_LLDP_DEST_NEAREST_NON_TPMR_BRIDGE: *const c_char = b"nearest-non-tpmr-bridge\0" as *const u8 as *const c_char;
pub const NM_MAJOR_VERSION: c_int = 1;
pub const NM_MICRO_VERSION: c_int = 0;
pub const NM_MINOR_VERSION: c_int = 24;
pub const NM_OBJECT_PATH: *const c_char = b"path\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_DBUS_CONNECTION: *const c_char = b"dbus-connection\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_FILENAME: *const c_char = b"filename\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_FLAGS: *const c_char = b"flags\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_PATH: *const c_char = b"path\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_UNSAVED: *const c_char = b"unsaved\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_VISIBLE: *const c_char = b"visible\0" as *const u8 as *const c_char;
pub const NM_SECRET_AGENT_OLD_AUTO_REGISTER: *const c_char = b"auto-register\0" as *const u8 as *const c_char;
pub const NM_SECRET_AGENT_OLD_CAPABILITIES: *const c_char = b"capabilities\0" as *const u8 as *const c_char;
pub const NM_SECRET_AGENT_OLD_DBUS_CONNECTION: *const c_char = b"dbus-connection\0" as *const u8 as *const c_char;
pub const NM_SECRET_AGENT_OLD_IDENTIFIER: *const c_char = b"identifier\0" as *const u8 as *const c_char;
pub const NM_SECRET_AGENT_OLD_REGISTERED: *const c_char = b"registered\0" as *const u8 as *const c_char;
pub const NM_SETTING_6LOWPAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_6LOWPAN_SETTING_NAME: *const c_char = b"6lowpan\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_ALTSUBJECT_MATCHES: *const c_char = b"altsubject-matches\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_ANONYMOUS_IDENTITY: *const c_char = b"anonymous-identity\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_AUTH_TIMEOUT: *const c_char = b"auth-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CA_CERT: *const c_char = b"ca-cert\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CA_CERT_PASSWORD: *const c_char = b"ca-cert-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CA_CERT_PASSWORD_FLAGS: *const c_char = b"ca-cert-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CA_PATH: *const c_char = b"ca-path\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PATH: *const c_char = b"file://\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PKCS11: *const c_char = b"pkcs11:\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CLIENT_CERT: *const c_char = b"client-cert\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CLIENT_CERT_PASSWORD: *const c_char = b"client-cert-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CLIENT_CERT_PASSWORD_FLAGS: *const c_char = b"client-cert-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_DOMAIN_MATCH: *const c_char = b"domain-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_DOMAIN_SUFFIX_MATCH: *const c_char = b"domain-suffix-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_EAP: *const c_char = b"eap\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_IDENTITY: *const c_char = b"identity\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_OPTIONAL: *const c_char = b"optional\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PAC_FILE: *const c_char = b"pac-file\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PASSWORD_RAW: *const c_char = b"password-raw\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PASSWORD_RAW_FLAGS: *const c_char = b"password-raw-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE1_AUTH_FLAGS: *const c_char = b"phase1-auth-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE1_FAST_PROVISIONING: *const c_char = b"phase1-fast-provisioning\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE1_PEAPLABEL: *const c_char = b"phase1-peaplabel\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE1_PEAPVER: *const c_char = b"phase1-peapver\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES: *const c_char = b"phase2-altsubject-matches\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_AUTH: *const c_char = b"phase2-auth\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_AUTHEAP: *const c_char = b"phase2-autheap\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CA_CERT: *const c_char = b"phase2-ca-cert\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD: *const c_char = b"phase2-ca-cert-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD_FLAGS: *const c_char = b"phase2-ca-cert-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CA_PATH: *const c_char = b"phase2-ca-path\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT: *const c_char = b"phase2-client-cert\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD: *const c_char = b"phase2-client-cert-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD_FLAGS: *const c_char = b"phase2-client-cert-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_DOMAIN_MATCH: *const c_char = b"phase2-domain-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH: *const c_char = b"phase2-domain-suffix-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY: *const c_char = b"phase2-private-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD: *const c_char = b"phase2-private-key-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS: *const c_char = b"phase2-private-key-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH: *const c_char = b"phase2-subject-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PIN: *const c_char = b"pin\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PIN_FLAGS: *const c_char = b"pin-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PRIVATE_KEY: *const c_char = b"private-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD: *const c_char = b"private-key-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS: *const c_char = b"private-key-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_SETTING_NAME: *const c_char = b"802-1x\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_SUBJECT_MATCH: *const c_char = b"subject-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_SYSTEM_CA_CERTS: *const c_char = b"system-ca-certs\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_ENCAPSULATION: *const c_char = b"encapsulation\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_ENCAPSULATION_LLC: *const c_char = b"llc\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_ENCAPSULATION_VCMUX: *const c_char = b"vcmux\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PROTOCOL: *const c_char = b"protocol\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PROTOCOL_IPOATM: *const c_char = b"ipoatm\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PROTOCOL_PPPOA: *const c_char = b"pppoa\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PROTOCOL_PPPOE: *const c_char = b"pppoe\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_SETTING_NAME: *const c_char = b"adsl\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_USERNAME: *const c_char = b"username\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_VCI: *const c_char = b"vci\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_VPI: *const c_char = b"vpi\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_BDADDR: *const c_char = b"bdaddr\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_SETTING_NAME: *const c_char = b"bluetooth\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_TYPE: *const c_char = b"type\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_TYPE_DUN: *const c_char = b"dun\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_TYPE_NAP: *const c_char = b"nap\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_TYPE_PANU: *const c_char = b"panu\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTIONS: *const c_char = b"options\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ACTIVE_SLAVE: *const c_char = b"active_slave\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_AD_ACTOR_SYSTEM: *const c_char = b"ad_actor_system\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO: *const c_char = b"ad_actor_sys_prio\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_AD_SELECT: *const c_char = b"ad_select\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_AD_USER_PORT_KEY: *const c_char = b"ad_user_port_key\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE: *const c_char = b"all_slaves_active\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS: *const c_char = b"arp_all_targets\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ARP_INTERVAL: *const c_char = b"arp_interval\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ARP_IP_TARGET: *const c_char = b"arp_ip_target\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ARP_VALIDATE: *const c_char = b"arp_validate\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_DOWNDELAY: *const c_char = b"downdelay\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_FAIL_OVER_MAC: *const c_char = b"fail_over_mac\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_LACP_RATE: *const c_char = b"lacp_rate\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_LP_INTERVAL: *const c_char = b"lp_interval\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_MIIMON: *const c_char = b"miimon\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_MIN_LINKS: *const c_char = b"min_links\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_NUM_GRAT_ARP: *const c_char = b"num_grat_arp\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_NUM_UNSOL_NA: *const c_char = b"num_unsol_na\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE: *const c_char = b"packets_per_slave\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_PRIMARY: *const c_char = b"primary\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_PRIMARY_RESELECT: *const c_char = b"primary_reselect\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_RESEND_IGMP: *const c_char = b"resend_igmp\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_TLB_DYNAMIC_LB: *const c_char = b"tlb_dynamic_lb\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_UPDELAY: *const c_char = b"updelay\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_USE_CARRIER: *const c_char = b"use_carrier\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY: *const c_char = b"xmit_hash_policy\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_SETTING_NAME: *const c_char = b"bond\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_AGEING_TIME: *const c_char = b"ageing-time\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_FORWARD_DELAY: *const c_char = b"forward-delay\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_GROUP_ADDRESS: *const c_char = b"group-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_GROUP_FORWARD_MASK: *const c_char = b"group-forward-mask\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_HELLO_TIME: *const c_char = b"hello-time\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_MAX_AGE: *const c_char = b"max-age\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_MULTICAST_QUERIER: *const c_char = b"multicast-querier\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_MULTICAST_QUERY_USE_IFADDR: *const c_char = b"multicast-query-use-ifaddr\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_MULTICAST_ROUTER: *const c_char = b"multicast-router\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_MULTICAST_SNOOPING: *const c_char = b"multicast-snooping\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE: *const c_char = b"hairpin-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PORT_PATH_COST: *const c_char = b"path-cost\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PORT_PRIORITY: *const c_char = b"priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PORT_SETTING_NAME: *const c_char = b"bridge-port\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PORT_VLANS: *const c_char = b"vlans\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PRIORITY: *const c_char = b"priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_SETTING_NAME: *const c_char = b"bridge\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_STP: *const c_char = b"stp\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_VLANS: *const c_char = b"vlans\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_VLAN_DEFAULT_PVID: *const c_char = b"vlan-default-pvid\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_VLAN_FILTERING: *const c_char = b"vlan-filtering\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_VLAN_PROTOCOL: *const c_char = b"vlan-protocol\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_VLAN_STATS_ENABLED: *const c_char = b"vlan-stats-enabled\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_NUMBER: *const c_char = b"number\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_SETTING_NAME: *const c_char = b"cdma\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_USERNAME: *const c_char = b"username\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_AUTH_RETRIES: *const c_char = b"auth-retries\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_AUTOCONNECT: *const c_char = b"autoconnect\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY: *const c_char = b"autoconnect-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT: c_int = 0;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX: c_int = 999;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN: c_int = -999;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES: *const c_char = b"autoconnect-retries\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES: *const c_char = b"autoconnect-slaves\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_GATEWAY_PING_TIMEOUT: *const c_char = b"gateway-ping-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_INTERFACE_NAME: *const c_char = b"interface-name\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_LLDP: *const c_char = b"lldp\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_LLMNR: *const c_char = b"llmnr\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_MASTER: *const c_char = b"master\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_MDNS: *const c_char = b"mdns\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_METERED: *const c_char = b"metered\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_MULTI_CONNECT: *const c_char = b"multi-connect\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_PERMISSIONS: *const c_char = b"permissions\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_READ_ONLY: *const c_char = b"read-only\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_SECONDARIES: *const c_char = b"secondaries\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_SETTING_NAME: *const c_char = b"connection\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_SLAVE_TYPE: *const c_char = b"slave-type\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_STABLE_ID: *const c_char = b"stable-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_TIMESTAMP: *const c_char = b"timestamp\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_TYPE: *const c_char = b"type\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_UUID: *const c_char = b"uuid\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_WAIT_DEVICE_TIMEOUT: *const c_char = b"wait-device-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_ZONE: *const c_char = b"zone\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FCOE_FLAGS: *const c_char = b"app-fcoe-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FCOE_MODE: *const c_char = b"app-fcoe-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FCOE_PRIORITY: *const c_char = b"app-fcoe-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FIP_FLAGS: *const c_char = b"app-fip-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FIP_PRIORITY: *const c_char = b"app-fip-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_ISCSI_FLAGS: *const c_char = b"app-iscsi-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_ISCSI_PRIORITY: *const c_char = b"app-iscsi-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_FCOE_MODE_FABRIC: *const c_char = b"fabric\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_FCOE_MODE_VN2VN: *const c_char = b"vn2vn\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_BANDWIDTH: *const c_char = b"priority-bandwidth\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_FLOW_CONTROL: *const c_char = b"priority-flow-control\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS: *const c_char = b"priority-flow-control-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_GROUP_BANDWIDTH: *const c_char = b"priority-group-bandwidth\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_GROUP_FLAGS: *const c_char = b"priority-group-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_GROUP_ID: *const c_char = b"priority-group-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_STRICT_BANDWIDTH: *const c_char = b"priority-strict-bandwidth\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_TRAFFIC_CLASS: *const c_char = b"priority-traffic-class\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_SETTING_NAME: *const c_char = b"dcb\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_ATTEMPTS: *const c_char = b"attempts\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_DEBUG: *const c_char = b"debug\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_EDNS0: *const c_char = b"edns0\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_INET6: *const c_char = b"inet6\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_IP6_BYTESTRING: *const c_char = b"ip6-bytestring\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_IP6_DOTINT: *const c_char = b"ip6-dotint\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_NDOTS: *const c_char = b"ndots\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_NO_CHECK_NAMES: *const c_char = b"no-check-names\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_NO_IP6_DOTINT: *const c_char = b"no-ip6-dotint\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_NO_RELOAD: *const c_char = b"no-reload\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_NO_TLD_QUERY: *const c_char = b"no-tld-query\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_ROTATE: *const c_char = b"rotate\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_SINGLE_REQUEST: *const c_char = b"single-request\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_SINGLE_REQUEST_REOPEN: *const c_char = b"single-request-reopen\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_TIMEOUT: *const c_char = b"timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_TRUST_AD: *const c_char = b"trust-ad\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_USE_VC: *const c_char = b"use-vc\0" as *const u8 as *const c_char;
pub const NM_SETTING_DUMMY_SETTING_NAME: *const c_char = b"dummy\0" as *const u8 as *const c_char;
pub const NM_SETTING_ETHTOOL_SETTING_NAME: *const c_char = b"ethtool\0" as *const u8 as *const c_char;
pub const NM_SETTING_GENERIC_SETTING_NAME: *const c_char = b"generic\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_APN: *const c_char = b"apn\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_AUTO_CONFIG: *const c_char = b"auto-config\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_DEVICE_ID: *const c_char = b"device-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_HOME_ONLY: *const c_char = b"home-only\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_NETWORK_ID: *const c_char = b"network-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_NUMBER: *const c_char = b"number\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_PIN: *const c_char = b"pin\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_PIN_FLAGS: *const c_char = b"pin-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_SETTING_NAME: *const c_char = b"gsm\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_SIM_ID: *const c_char = b"sim-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_SIM_OPERATOR_ID: *const c_char = b"sim-operator-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_USERNAME: *const c_char = b"username\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_P_KEY: *const c_char = b"p-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_SETTING_NAME: *const c_char = b"infiniband\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_TRANSPORT_MODE: *const c_char = b"transport-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID: *const c_char = b"dhcp-client-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_DHCP_FQDN: *const c_char = b"dhcp-fqdn\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_AUTO: *const c_char = b"auto\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_DISABLED: *const c_char = b"disabled\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL: *const c_char = b"link-local\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_MANUAL: *const c_char = b"manual\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_SHARED: *const c_char = b"shared\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_SETTING_NAME: *const c_char = b"ipv4\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE: *const c_char = b"addr-gen-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_DHCP_DUID: *const c_char = b"dhcp-duid\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_IP6_PRIVACY: *const c_char = b"ip6-privacy\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_AUTO: *const c_char = b"auto\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_DHCP: *const c_char = b"dhcp\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_DISABLED: *const c_char = b"disabled\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_IGNORE: *const c_char = b"ignore\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL: *const c_char = b"link-local\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_MANUAL: *const c_char = b"manual\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_SHARED: *const c_char = b"shared\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_RA_TIMEOUT: *const c_char = b"ra-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_SETTING_NAME: *const c_char = b"ipv6\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_TOKEN: *const c_char = b"token\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_ADDRESSES: *const c_char = b"addresses\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DAD_TIMEOUT: *const c_char = b"dad-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX: c_int = 30000;
pub const NM_SETTING_IP_CONFIG_DHCP_HOSTNAME: *const c_char = b"dhcp-hostname\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DHCP_HOSTNAME_FLAGS: *const c_char = b"dhcp-hostname-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DHCP_IAID: *const c_char = b"dhcp-iaid\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME: *const c_char = b"dhcp-send-hostname\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DHCP_TIMEOUT: *const c_char = b"dhcp-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DNS: *const c_char = b"dns\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DNS_OPTIONS: *const c_char = b"dns-options\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DNS_PRIORITY: *const c_char = b"dns-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DNS_SEARCH: *const c_char = b"dns-search\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_GATEWAY: *const c_char = b"gateway\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS: *const c_char = b"ignore-auto-dns\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES: *const c_char = b"ignore-auto-routes\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_MAY_FAIL: *const c_char = b"may-fail\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_METHOD: *const c_char = b"method\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_NEVER_DEFAULT: *const c_char = b"never-default\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_ROUTES: *const c_char = b"routes\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_ROUTE_METRIC: *const c_char = b"route-metric\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_ROUTE_TABLE: *const c_char = b"route-table\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_ROUTING_RULES: *const c_char = b"routing-rules\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_ENCAPSULATION_LIMIT: *const c_char = b"encapsulation-limit\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_FLAGS: *const c_char = b"flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_FLOW_LABEL: *const c_char = b"flow-label\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_INPUT_KEY: *const c_char = b"input-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_LOCAL: *const c_char = b"local\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_OUTPUT_KEY: *const c_char = b"output-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_PATH_MTU_DISCOVERY: *const c_char = b"path-mtu-discovery\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_REMOTE: *const c_char = b"remote\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_SETTING_NAME: *const c_char = b"ip-tunnel\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_TTL: *const c_char = b"ttl\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_ENCRYPT: *const c_char = b"encrypt\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_MKA_CAK: *const c_char = b"mka-cak\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_MKA_CAK_FLAGS: *const c_char = b"mka-cak-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_MKA_CAK_LENGTH: c_int = 32;
pub const NM_SETTING_MACSEC_MKA_CKN: *const c_char = b"mka-ckn\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_MKA_CKN_LENGTH: c_int = 64;
pub const NM_SETTING_MACSEC_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_PORT: *const c_char = b"port\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_SEND_SCI: *const c_char = b"send-sci\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_SETTING_NAME: *const c_char = b"macsec\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_VALIDATION: *const c_char = b"validation\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_PROMISCUOUS: *const c_char = b"promiscuous\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_SETTING_NAME: *const c_char = b"macvlan\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_TAP: *const c_char = b"tap\0" as *const u8 as *const c_char;
pub const NM_SETTING_MATCH_INTERFACE_NAME: *const c_char = b"interface-name\0" as *const u8 as *const c_char;
pub const NM_SETTING_MATCH_SETTING_NAME: *const c_char = b"match\0" as *const u8 as *const c_char;
pub const NM_SETTING_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_SETTING_OLPC_MESH_CHANNEL: *const c_char = b"channel\0" as *const u8 as *const c_char;
pub const NM_SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS: *const c_char = b"dhcp-anycast-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_OLPC_MESH_SETTING_NAME: *const c_char = b"802-11-olpc-mesh\0" as *const u8 as *const c_char;
pub const NM_SETTING_OLPC_MESH_SSID: *const c_char = b"ssid\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_BRIDGE_DATAPATH_TYPE: *const c_char = b"datapath-type\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_BRIDGE_FAIL_MODE: *const c_char = b"fail-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_BRIDGE_MCAST_SNOOPING_ENABLE: *const c_char = b"mcast-snooping-enable\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_BRIDGE_RSTP_ENABLE: *const c_char = b"rstp-enable\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_BRIDGE_SETTING_NAME: *const c_char = b"ovs-bridge\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_BRIDGE_STP_ENABLE: *const c_char = b"stp-enable\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_DPDK_DEVARGS: *const c_char = b"devargs\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_DPDK_SETTING_NAME: *const c_char = b"ovs-dpdk\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_INTERFACE_SETTING_NAME: *const c_char = b"ovs-interface\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_INTERFACE_TYPE: *const c_char = b"type\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_PATCH_PEER: *const c_char = b"peer\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_PATCH_SETTING_NAME: *const c_char = b"ovs-patch\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_PORT_BOND_DOWNDELAY: *const c_char = b"bond-downdelay\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_PORT_BOND_MODE: *const c_char = b"bond-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_PORT_BOND_UPDELAY: *const c_char = b"bond-updelay\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_PORT_LACP: *const c_char = b"lacp\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_PORT_SETTING_NAME: *const c_char = b"ovs-port\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_PORT_TAG: *const c_char = b"tag\0" as *const u8 as *const c_char;
pub const NM_SETTING_OVS_PORT_VLAN_MODE: *const c_char = b"vlan-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_PARAM_FUZZY_IGNORE: c_int = 8;
pub const NM_SETTING_PARAM_REQUIRED: c_int = 2;
pub const NM_SETTING_PARAM_SECRET: c_int = 4;
pub const NM_SETTING_PPPOE_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPPOE_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPPOE_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPPOE_SERVICE: *const c_char = b"service\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPPOE_SETTING_NAME: *const c_char = b"pppoe\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPPOE_USERNAME: *const c_char = b"username\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_BAUD: *const c_char = b"baud\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_CRTSCTS: *const c_char = b"crtscts\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_LCP_ECHO_FAILURE: *const c_char = b"lcp-echo-failure\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_LCP_ECHO_INTERVAL: *const c_char = b"lcp-echo-interval\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_MPPE_STATEFUL: *const c_char = b"mppe-stateful\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_MRU: *const c_char = b"mru\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_NOAUTH: *const c_char = b"noauth\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_NOBSDCOMP: *const c_char = b"nobsdcomp\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_NODEFLATE: *const c_char = b"nodeflate\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_NO_VJ_COMP: *const c_char = b"no-vj-comp\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_CHAP: *const c_char = b"refuse-chap\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_EAP: *const c_char = b"refuse-eap\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_MSCHAP: *const c_char = b"refuse-mschap\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_MSCHAPV2: *const c_char = b"refuse-mschapv2\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_PAP: *const c_char = b"refuse-pap\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REQUIRE_MPPE: *const c_char = b"require-mppe\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REQUIRE_MPPE_128: *const c_char = b"require-mppe-128\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_SETTING_NAME: *const c_char = b"ppp\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_BROWSER_ONLY: *const c_char = b"browser-only\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_METHOD: *const c_char = b"method\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_PAC_SCRIPT: *const c_char = b"pac-script\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_PAC_URL: *const c_char = b"pac-url\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_SETTING_NAME: *const c_char = b"proxy\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_BAUD: *const c_char = b"baud\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_BITS: *const c_char = b"bits\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_PARITY: *const c_char = b"parity\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_SEND_DELAY: *const c_char = b"send-delay\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_SETTING_NAME: *const c_char = b"serial\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_STOPBITS: *const c_char = b"stopbits\0" as *const u8 as *const c_char;
pub const NM_SETTING_SRIOV_AUTOPROBE_DRIVERS: *const c_char = b"autoprobe-drivers\0" as *const u8 as *const c_char;
pub const NM_SETTING_SRIOV_SETTING_NAME: *const c_char = b"sriov\0" as *const u8 as *const c_char;
pub const NM_SETTING_SRIOV_TOTAL_VFS: *const c_char = b"total-vfs\0" as *const u8 as *const c_char;
pub const NM_SETTING_SRIOV_VFS: *const c_char = b"vfs\0" as *const u8 as *const c_char;
pub const NM_SETTING_TC_CONFIG_QDISCS: *const c_char = b"qdiscs\0" as *const u8 as *const c_char;
pub const NM_SETTING_TC_CONFIG_SETTING_NAME: *const c_char = b"tc\0" as *const u8 as *const c_char;
pub const NM_SETTING_TC_CONFIG_TFILTERS: *const c_char = b"tfilters\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_CONFIG: *const c_char = b"config\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_LINK_WATCHERS: *const c_char = b"link-watchers\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_MCAST_REJOIN_COUNT: *const c_char = b"mcast-rejoin-count\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_MCAST_REJOIN_INTERVAL: *const c_char = b"mcast-rejoin-interval\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_NOTIFY_MCAST_COUNT_ACTIVEBACKUP_DEFAULT: c_int = 1;
pub const NM_SETTING_TEAM_NOTIFY_PEERS_COUNT: *const c_char = b"notify-peers-count\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_NOTIFY_PEERS_COUNT_ACTIVEBACKUP_DEFAULT: c_int = 1;
pub const NM_SETTING_TEAM_NOTIFY_PEERS_INTERVAL: *const c_char = b"notify-peers-interval\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_CONFIG: *const c_char = b"config\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_LACP_KEY: *const c_char = b"lacp-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_LACP_PRIO: *const c_char = b"lacp-prio\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_LACP_PRIO_DEFAULT: c_int = 255;
pub const NM_SETTING_TEAM_PORT_LINK_WATCHERS: *const c_char = b"link-watchers\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_PRIO: *const c_char = b"prio\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_QUEUE_ID: *const c_char = b"queue-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_QUEUE_ID_DEFAULT: c_int = -1;
pub const NM_SETTING_TEAM_PORT_SETTING_NAME: *const c_char = b"team-port\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_STICKY: *const c_char = b"sticky\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER: *const c_char = b"runner\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_ACTIVE: *const c_char = b"runner-active\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_ACTIVEBACKUP: *const c_char = b"activebackup\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY: *const c_char = b"runner-agg-select-policy\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_BANDWIDTH: *const c_char = b"bandwidth\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_COUNT: *const c_char = b"count\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_LACP_PRIO: *const c_char = b"lacp_prio\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_LACP_PRIO_STABLE: *const c_char = b"lacp_prio_stable\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_PORT_CONFIG: *const c_char = b"port_config\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_BROADCAST: *const c_char = b"broadcast\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_FAST_RATE: *const c_char = b"runner-fast-rate\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY: *const c_char = b"runner-hwaddr-policy\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_BY_ACTIVE: *const c_char = b"by_active\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_ONLY_ACTIVE: *const c_char = b"only_active\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_HWADDR_POLICY_SAME_ALL: *const c_char = b"same_all\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_LACP: *const c_char = b"lacp\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_LOADBALANCE: *const c_char = b"loadbalance\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_MIN_PORTS: *const c_char = b"runner-min-ports\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_RANDOM: *const c_char = b"random\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_ROUNDROBIN: *const c_char = b"roundrobin\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_SYS_PRIO: *const c_char = b"runner-sys-prio\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_SYS_PRIO_DEFAULT: c_int = 65535;
pub const NM_SETTING_TEAM_RUNNER_TX_BALANCER: *const c_char = b"runner-tx-balancer\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_TX_BALANCER_INTERVAL: *const c_char = b"runner-tx-balancer-interval\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_RUNNER_TX_BALANCER_INTERVAL_DEFAULT: c_int = 50;
pub const NM_SETTING_TEAM_RUNNER_TX_HASH: *const c_char = b"runner-tx-hash\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_SETTING_NAME: *const c_char = b"team\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_GROUP: *const c_char = b"group\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_MULTI_QUEUE: *const c_char = b"multi-queue\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_OWNER: *const c_char = b"owner\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_PI: *const c_char = b"pi\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_SETTING_NAME: *const c_char = b"tun\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_VNET_HDR: *const c_char = b"vnet-hdr\0" as *const u8 as *const c_char;
pub const NM_SETTING_USER_DATA: *const c_char = b"data\0" as *const u8 as *const c_char;
pub const NM_SETTING_USER_SETTING_NAME: *const c_char = b"user\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_EGRESS_PRIORITY_MAP: *const c_char = b"egress-priority-map\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_FLAGS: *const c_char = b"flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_INGRESS_PRIORITY_MAP: *const c_char = b"ingress-priority-map\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_SETTING_NAME: *const c_char = b"vlan\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_DATA: *const c_char = b"data\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_PERSISTENT: *const c_char = b"persistent\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_SECRETS: *const c_char = b"secrets\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_SERVICE_TYPE: *const c_char = b"service-type\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_SETTING_NAME: *const c_char = b"vpn\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_TIMEOUT: *const c_char = b"timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_USER_NAME: *const c_char = b"user-name\0" as *const u8 as *const c_char;
pub const NM_SETTING_VRF_SETTING_NAME: *const c_char = b"vrf\0" as *const u8 as *const c_char;
pub const NM_SETTING_VRF_TABLE: *const c_char = b"table\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_AGEING: *const c_char = b"ageing\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_DESTINATION_PORT: *const c_char = b"destination-port\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_L2_MISS: *const c_char = b"l2-miss\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_L3_MISS: *const c_char = b"l3-miss\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_LEARNING: *const c_char = b"learning\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_LIMIT: *const c_char = b"limit\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_LOCAL: *const c_char = b"local\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_PROXY: *const c_char = b"proxy\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_REMOTE: *const c_char = b"remote\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_RSC: *const c_char = b"rsc\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_SETTING_NAME: *const c_char = b"vxlan\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_SOURCE_PORT_MAX: *const c_char = b"source-port-max\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_SOURCE_PORT_MIN: *const c_char = b"source-port-min\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_TTL: *const c_char = b"ttl\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIFI_P2P_PEER: *const c_char = b"peer\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIFI_P2P_SETTING_NAME: *const c_char = b"wifi-p2p\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIFI_P2P_WFD_IES: *const c_char = b"wfd-ies\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIFI_P2P_WPS_METHOD: *const c_char = b"wps-method\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIMAX_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIMAX_NETWORK_NAME: *const c_char = b"network-name\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIMAX_SETTING_NAME: *const c_char = b"wimax\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_AUTO_NEGOTIATE: *const c_char = b"auto-negotiate\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_CLONED_MAC_ADDRESS: *const c_char = b"cloned-mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_DUPLEX: *const c_char = b"duplex\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK: *const c_char = b"generate-mac-address-mask\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_MAC_ADDRESS_BLACKLIST: *const c_char = b"mac-address-blacklist\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_PORT: *const c_char = b"port\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_S390_NETTYPE: *const c_char = b"s390-nettype\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_S390_OPTIONS: *const c_char = b"s390-options\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_S390_SUBCHANNELS: *const c_char = b"s390-subchannels\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_SETTING_NAME: *const c_char = b"802-3-ethernet\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_SPEED: *const c_char = b"speed\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_WAKE_ON_LAN: *const c_char = b"wake-on-lan\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_PASSWORD: *const c_char = b"wake-on-lan-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_FWMARK: *const c_char = b"fwmark\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_IP4_AUTO_DEFAULT_ROUTE: *const c_char = b"ip4-auto-default-route\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_IP6_AUTO_DEFAULT_ROUTE: *const c_char = b"ip6-auto-default-route\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_LISTEN_PORT: *const c_char = b"listen-port\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_PEERS: *const c_char = b"peers\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_PEER_ROUTES: *const c_char = b"peer-routes\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_PRIVATE_KEY: *const c_char = b"private-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_PRIVATE_KEY_FLAGS: *const c_char = b"private-key-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIREGUARD_SETTING_NAME: *const c_char = b"wireguard\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_BAND: *const c_char = b"band\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_BSSID: *const c_char = b"bssid\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_CHANNEL: *const c_char = b"channel\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS: *const c_char = b"cloned-mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK: *const c_char = b"generate-mac-address-mask\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_HIDDEN: *const c_char = b"hidden\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST: *const c_char = b"mac-address-blacklist\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION: *const c_char = b"mac-address-randomization\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MODE_ADHOC: *const c_char = b"adhoc\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MODE_AP: *const c_char = b"ap\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MODE_INFRA: *const c_char = b"infrastructure\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MODE_MESH: *const c_char = b"mesh\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_POWERSAVE: *const c_char = b"powersave\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_RATE: *const c_char = b"rate\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_AUTH_ALG: *const c_char = b"auth-alg\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_FILS: *const c_char = b"fils\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_GROUP: *const c_char = b"group\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_KEY_MGMT: *const c_char = b"key-mgmt\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD: *const c_char = b"leap-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS: *const c_char = b"leap-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME: *const c_char = b"leap-username\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_PAIRWISE: *const c_char = b"pairwise\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_PMF: *const c_char = b"pmf\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_PROTO: *const c_char = b"proto\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_PSK: *const c_char = b"psk\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS: *const c_char = b"psk-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_SETTING_NAME: *const c_char = b"802-11-wireless-security\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY0: *const c_char = b"wep-key0\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY1: *const c_char = b"wep-key1\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY2: *const c_char = b"wep-key2\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY3: *const c_char = b"wep-key3\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS: *const c_char = b"wep-key-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE: *const c_char = b"wep-key-type\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX: *const c_char = b"wep-tx-keyidx\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD: *const c_char = b"wps-method\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SEEN_BSSIDS: *const c_char = b"seen-bssids\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SETTING_NAME: *const c_char = b"802-11-wireless\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SSID: *const c_char = b"ssid\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_TX_POWER: *const c_char = b"tx-power\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN: *const c_char = b"wake-on-wlan\0" as *const u8 as *const c_char;
pub const NM_SETTING_WPAN_CHANNEL: *const c_char = b"channel\0" as *const u8 as *const c_char;
pub const NM_SETTING_WPAN_CHANNEL_DEFAULT: c_int = -1;
pub const NM_SETTING_WPAN_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WPAN_PAGE: *const c_char = b"page\0" as *const u8 as *const c_char;
pub const NM_SETTING_WPAN_PAGE_DEFAULT: c_int = -1;
pub const NM_SETTING_WPAN_PAN_ID: *const c_char = b"pan-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_WPAN_SETTING_NAME: *const c_char = b"wpan\0" as *const u8 as *const c_char;
pub const NM_SETTING_WPAN_SHORT_ADDRESS: *const c_char = b"short-address\0" as *const u8 as *const c_char;
pub const NM_SRIOV_VF_ATTRIBUTE_MAC: *const c_char = b"mac\0" as *const u8 as *const c_char;
pub const NM_SRIOV_VF_ATTRIBUTE_MAX_TX_RATE: *const c_char = b"max-tx-rate\0" as *const u8 as *const c_char;
pub const NM_SRIOV_VF_ATTRIBUTE_MIN_TX_RATE: *const c_char = b"min-tx-rate\0" as *const u8 as *const c_char;
pub const NM_SRIOV_VF_ATTRIBUTE_SPOOF_CHECK: *const c_char = b"spoof-check\0" as *const u8 as *const c_char;
pub const NM_SRIOV_VF_ATTRIBUTE_TRUST: *const c_char = b"trust\0" as *const u8 as *const c_char;
pub const NM_TEAM_LINK_WATCHER_ARP_PING: *const c_char = b"arp_ping\0" as *const u8 as *const c_char;
pub const NM_TEAM_LINK_WATCHER_ETHTOOL: *const c_char = b"ethtool\0" as *const u8 as *const c_char;
pub const NM_TEAM_LINK_WATCHER_NSNA_PING: *const c_char = b"nsna_ping\0" as *const u8 as *const c_char;
pub const NM_UTILS_HWADDR_LEN_MAX: c_int = 20;
pub const NM_VLAN_FLAGS_ALL: c_int = 15;
pub const NM_VPN_CONNECTION_BANNER: *const c_char = b"banner\0" as *const u8 as *const c_char;
pub const NM_VPN_CONNECTION_VPN_STATE: *const c_char = b"vpn-state\0" as *const u8 as *const c_char;
pub const NM_VPN_DBUS_PLUGIN_INTERFACE: *const c_char = b"org.freedesktop.NetworkManager.VPN.Plugin\0" as *const u8 as *const c_char;
pub const NM_VPN_DBUS_PLUGIN_PATH: *const c_char = b"/org/freedesktop/NetworkManager/VPN/Plugin\0" as *const u8 as *const c_char;
pub const NM_VPN_EDITOR_PLUGIN_DESCRIPTION: *const c_char = b"description\0" as *const u8 as *const c_char;
pub const NM_VPN_EDITOR_PLUGIN_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_VPN_EDITOR_PLUGIN_SERVICE: *const c_char = b"service\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CAN_PERSIST: *const c_char = b"can-persist\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_BANNER: *const c_char = b"banner\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_EXT_GATEWAY: *const c_char = b"gateway\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_HAS_IP4: *const c_char = b"has-ip4\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_HAS_IP6: *const c_char = b"has-ip6\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_PROXY_PAC: *const c_char = b"pac\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_TUNDEV: *const c_char = b"tundev\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_FILENAME: *const c_char = b"filename\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_KEYFILE: *const c_char = b"keyfile\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_CONNECTION: *const c_char = b"VPN Connection\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_GNOME: *const c_char = b"GNOME\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_LIBNM: *const c_char = b"libnm\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_ADDRESS: *const c_char = b"address\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_DNS: *const c_char = b"dns\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_DOMAIN: *const c_char = b"domain\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_DOMAINS: *const c_char = b"domains\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY: *const c_char = b"internal-gateway\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_MSS: *const c_char = b"mss\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_NBNS: *const c_char = b"nbns\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT: *const c_char = b"never-default\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_PREFIX: *const c_char = b"prefix\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_PRESERVE_ROUTES: *const c_char = b"preserve-routes\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_PTP: *const c_char = b"ptp\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_ROUTES: *const c_char = b"routes\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_ADDRESS: *const c_char = b"address\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_DNS: *const c_char = b"dns\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_DOMAIN: *const c_char = b"domain\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_DOMAINS: *const c_char = b"domains\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_INT_GATEWAY: *const c_char = b"internal-gateway\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_MSS: *const c_char = b"mss\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_NEVER_DEFAULT: *const c_char = b"never-default\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_PREFIX: *const c_char = b"prefix\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_PRESERVE_ROUTES: *const c_char = b"preserve-routes\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_PTP: *const c_char = b"ptp\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_ROUTES: *const c_char = b"routes\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_OLD_DBUS_SERVICE_NAME: *const c_char = b"service-name\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_OLD_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME: *const c_char = b"service-name\0" as *const u8 as *const c_char;
pub const NM_VPN_SERVICE_PLUGIN_DBUS_WATCH_PEER: *const c_char = b"watch-peer\0" as *const u8 as *const c_char;
pub const NM_VPN_SERVICE_PLUGIN_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_FLAGS: *const c_char = b"flags\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_LAST_SEEN: *const c_char = b"last-seen\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_MANUFACTURER: *const c_char = b"manufacturer\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_MODEL: *const c_char = b"model\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_MODEL_NUMBER: *const c_char = b"model-number\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_SERIAL: *const c_char = b"serial\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_STRENGTH: *const c_char = b"strength\0" as *const u8 as *const c_char;
pub const NM_WIFI_P2P_PEER_WFD_IES: *const c_char = b"wfd-ies\0" as *const u8 as *const c_char;
pub const NM_WIMAX_NSP_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_WIMAX_NSP_NETWORK_TYPE: *const c_char = b"network-type\0" as *const u8 as *const c_char;
pub const NM_WIMAX_NSP_SIGNAL_QUALITY: *const c_char = b"signal-quality\0" as *const u8 as *const c_char;
pub const NM_WIREGUARD_PEER_ATTR_ALLOWED_IPS: *const c_char = b"allowed-ips\0" as *const u8 as *const c_char;
pub const NM_WIREGUARD_PEER_ATTR_ENDPOINT: *const c_char = b"endpoint\0" as *const u8 as *const c_char;
pub const NM_WIREGUARD_PEER_ATTR_PERSISTENT_KEEPALIVE: *const c_char = b"persistent-keepalive\0" as *const u8 as *const c_char;
pub const NM_WIREGUARD_PEER_ATTR_PRESHARED_KEY: *const c_char = b"preshared-key\0" as *const u8 as *const c_char;
pub const NM_WIREGUARD_PEER_ATTR_PRESHARED_KEY_FLAGS: *const c_char = b"preshared-key-flags\0" as *const u8 as *const c_char;
pub const NM_WIREGUARD_PEER_ATTR_PUBLIC_KEY: *const c_char = b"public-key\0" as *const u8 as *const c_char;
pub const NM_WIREGUARD_PUBLIC_KEY_LEN: c_int = 32;
pub const NM_WIREGUARD_SYMMETRIC_KEY_LEN: c_int = 32;

// Flags
pub type NM80211ApFlags = c_uint;
pub const NM_802_11_AP_FLAGS_NONE: NM80211ApFlags = 0;
pub const NM_802_11_AP_FLAGS_PRIVACY: NM80211ApFlags = 1;
pub const NM_802_11_AP_FLAGS_WPS: NM80211ApFlags = 2;
pub const NM_802_11_AP_FLAGS_WPS_PBC: NM80211ApFlags = 4;
pub const NM_802_11_AP_FLAGS_WPS_PIN: NM80211ApFlags = 8;

pub type NM80211ApSecurityFlags = c_uint;
pub const NM_802_11_AP_SEC_NONE: NM80211ApSecurityFlags = 0;
pub const NM_802_11_AP_SEC_PAIR_WEP40: NM80211ApSecurityFlags = 1;
pub const NM_802_11_AP_SEC_PAIR_WEP104: NM80211ApSecurityFlags = 2;
pub const NM_802_11_AP_SEC_PAIR_TKIP: NM80211ApSecurityFlags = 4;
pub const NM_802_11_AP_SEC_PAIR_CCMP: NM80211ApSecurityFlags = 8;
pub const NM_802_11_AP_SEC_GROUP_WEP40: NM80211ApSecurityFlags = 16;
pub const NM_802_11_AP_SEC_GROUP_WEP104: NM80211ApSecurityFlags = 32;
pub const NM_802_11_AP_SEC_GROUP_TKIP: NM80211ApSecurityFlags = 64;
pub const NM_802_11_AP_SEC_GROUP_CCMP: NM80211ApSecurityFlags = 128;
pub const NM_802_11_AP_SEC_KEY_MGMT_PSK: NM80211ApSecurityFlags = 256;
pub const NM_802_11_AP_SEC_KEY_MGMT_802_1X: NM80211ApSecurityFlags = 512;
pub const NM_802_11_AP_SEC_KEY_MGMT_SAE: NM80211ApSecurityFlags = 1024;
pub const NM_802_11_AP_SEC_KEY_MGMT_OWE: NM80211ApSecurityFlags = 2048;

pub type NMActivationStateFlags = c_uint;
pub const NM_ACTIVATION_STATE_FLAG_NONE: NMActivationStateFlags = 0;
pub const NM_ACTIVATION_STATE_FLAG_IS_MASTER: NMActivationStateFlags = 1;
pub const NM_ACTIVATION_STATE_FLAG_IS_SLAVE: NMActivationStateFlags = 2;
pub const NM_ACTIVATION_STATE_FLAG_LAYER2_READY: NMActivationStateFlags = 4;
pub const NM_ACTIVATION_STATE_FLAG_IP4_READY: NMActivationStateFlags = 8;
pub const NM_ACTIVATION_STATE_FLAG_IP6_READY: NMActivationStateFlags = 16;
pub const NM_ACTIVATION_STATE_FLAG_MASTER_HAS_SLAVES: NMActivationStateFlags = 32;
pub const NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY: NMActivationStateFlags = 64;

pub type NMBluetoothCapabilities = c_uint;
pub const NM_BT_CAPABILITY_NONE: NMBluetoothCapabilities = 0;
pub const NM_BT_CAPABILITY_DUN: NMBluetoothCapabilities = 1;
pub const NM_BT_CAPABILITY_NAP: NMBluetoothCapabilities = 2;

pub type NMCheckpointCreateFlags = c_uint;
pub const NM_CHECKPOINT_CREATE_FLAG_NONE: NMCheckpointCreateFlags = 0;
pub const NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL: NMCheckpointCreateFlags = 1;
pub const NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS: NMCheckpointCreateFlags = 2;
pub const NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES: NMCheckpointCreateFlags = 4;
pub const NM_CHECKPOINT_CREATE_FLAG_ALLOW_OVERLAPPING: NMCheckpointCreateFlags = 8;

pub type NMClientInstanceFlags = c_uint;
pub const NM_CLIENT_INSTANCE_FLAGS_NONE: NMClientInstanceFlags = 0;
pub const NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS: NMClientInstanceFlags = 1;

pub type NMConnectionSerializationFlags = c_uint;
pub const NM_CONNECTION_SERIALIZE_ALL: NMConnectionSerializationFlags = 0;
pub const NM_CONNECTION_SERIALIZE_NO_SECRETS: NMConnectionSerializationFlags = 1;
pub const NM_CONNECTION_SERIALIZE_ONLY_SECRETS: NMConnectionSerializationFlags = 2;
pub const NM_CONNECTION_SERIALIZE_WITH_SECRETS_AGENT_OWNED: NMConnectionSerializationFlags = 4;

pub type NMDeviceCapabilities = c_uint;
pub const NM_DEVICE_CAP_NONE: NMDeviceCapabilities = 0;
pub const NM_DEVICE_CAP_NM_SUPPORTED: NMDeviceCapabilities = 1;
pub const NM_DEVICE_CAP_CARRIER_DETECT: NMDeviceCapabilities = 2;
pub const NM_DEVICE_CAP_IS_SOFTWARE: NMDeviceCapabilities = 4;
pub const NM_DEVICE_CAP_SRIOV: NMDeviceCapabilities = 8;

pub type NMDeviceInterfaceFlags = c_uint;
pub const NM_DEVICE_INTERFACE_FLAG_UP: NMDeviceInterfaceFlags = 1;
pub const NM_DEVICE_INTERFACE_FLAG_LOWER_UP: NMDeviceInterfaceFlags = 2;
pub const NM_DEVICE_INTERFACE_FLAG_CARRIER: NMDeviceInterfaceFlags = 65536;

pub type NMDeviceModemCapabilities = c_uint;
pub const NM_DEVICE_MODEM_CAPABILITY_NONE: NMDeviceModemCapabilities = 0;
pub const NM_DEVICE_MODEM_CAPABILITY_POTS: NMDeviceModemCapabilities = 1;
pub const NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO: NMDeviceModemCapabilities = 2;
pub const NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS: NMDeviceModemCapabilities = 4;
pub const NM_DEVICE_MODEM_CAPABILITY_LTE: NMDeviceModemCapabilities = 8;

pub type NMDeviceWifiCapabilities = c_uint;
pub const NM_WIFI_DEVICE_CAP_NONE: NMDeviceWifiCapabilities = 0;
pub const NM_WIFI_DEVICE_CAP_CIPHER_WEP40: NMDeviceWifiCapabilities = 1;
pub const NM_WIFI_DEVICE_CAP_CIPHER_WEP104: NMDeviceWifiCapabilities = 2;
pub const NM_WIFI_DEVICE_CAP_CIPHER_TKIP: NMDeviceWifiCapabilities = 4;
pub const NM_WIFI_DEVICE_CAP_CIPHER_CCMP: NMDeviceWifiCapabilities = 8;
pub const NM_WIFI_DEVICE_CAP_WPA: NMDeviceWifiCapabilities = 16;
pub const NM_WIFI_DEVICE_CAP_RSN: NMDeviceWifiCapabilities = 32;
pub const NM_WIFI_DEVICE_CAP_AP: NMDeviceWifiCapabilities = 64;
pub const NM_WIFI_DEVICE_CAP_ADHOC: NMDeviceWifiCapabilities = 128;
pub const NM_WIFI_DEVICE_CAP_FREQ_VALID: NMDeviceWifiCapabilities = 256;
pub const NM_WIFI_DEVICE_CAP_FREQ_2GHZ: NMDeviceWifiCapabilities = 512;
pub const NM_WIFI_DEVICE_CAP_FREQ_5GHZ: NMDeviceWifiCapabilities = 1024;
pub const NM_WIFI_DEVICE_CAP_MESH: NMDeviceWifiCapabilities = 4096;
pub const NM_WIFI_DEVICE_CAP_IBSS_RSN: NMDeviceWifiCapabilities = 8192;

pub type NMDhcpHostnameFlags = c_uint;
pub const NM_DHCP_HOSTNAME_FLAG_NONE: NMDhcpHostnameFlags = 0;
pub const NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE: NMDhcpHostnameFlags = 1;
pub const NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED: NMDhcpHostnameFlags = 2;
pub const NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE: NMDhcpHostnameFlags = 4;
pub const NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS: NMDhcpHostnameFlags = 8;

pub type NMIPAddressCmpFlags = c_uint;
pub const NM_IP_ADDRESS_CMP_FLAGS_NONE: NMIPAddressCmpFlags = 0;
pub const NM_IP_ADDRESS_CMP_FLAGS_WITH_ATTRS: NMIPAddressCmpFlags = 1;

pub type NMIPRoutingRuleAsStringFlags = c_uint;
pub const NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE: NMIPRoutingRuleAsStringFlags = 0;
pub const NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET: NMIPRoutingRuleAsStringFlags = 1;
pub const NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6: NMIPRoutingRuleAsStringFlags = 2;
pub const NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE: NMIPRoutingRuleAsStringFlags = 4;

pub type NMIPTunnelFlags = c_uint;
pub const NM_IP_TUNNEL_FLAG_NONE: NMIPTunnelFlags = 0;
pub const NM_IP_TUNNEL_FLAG_IP6_IGN_ENCAP_LIMIT: NMIPTunnelFlags = 1;
pub const NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_TCLASS: NMIPTunnelFlags = 2;
pub const NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FLOWLABEL: NMIPTunnelFlags = 4;
pub const NM_IP_TUNNEL_FLAG_IP6_MIP6_DEV: NMIPTunnelFlags = 8;
pub const NM_IP_TUNNEL_FLAG_IP6_RCV_DSCP_COPY: NMIPTunnelFlags = 16;
pub const NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FWMARK: NMIPTunnelFlags = 32;

pub type NMManagerReloadFlags = c_uint;
pub const NM_MANAGER_RELOAD_FLAG_CONF: NMManagerReloadFlags = 1;
pub const NM_MANAGER_RELOAD_FLAG_DNS_RC: NMManagerReloadFlags = 2;
pub const NM_MANAGER_RELOAD_FLAG_DNS_FULL: NMManagerReloadFlags = 4;

pub type NMSecretAgentCapabilities = c_uint;
pub const NM_SECRET_AGENT_CAPABILITY_NONE: NMSecretAgentCapabilities = 0;
pub const NM_SECRET_AGENT_CAPABILITY_VPN_HINTS: NMSecretAgentCapabilities = 1;
pub const NM_SECRET_AGENT_CAPABILITY_LAST: NMSecretAgentCapabilities = 1;

pub type NMSecretAgentGetSecretsFlags = c_uint;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE: NMSecretAgentGetSecretsFlags = 0;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION: NMSecretAgentGetSecretsFlags = 1;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW: NMSecretAgentGetSecretsFlags = 2;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED: NMSecretAgentGetSecretsFlags = 4;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_WPS_PBC_ACTIVE: NMSecretAgentGetSecretsFlags = 8;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM: NMSecretAgentGetSecretsFlags = 2147483648;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS: NMSecretAgentGetSecretsFlags = 1073741824;

pub type NMSetting8021xAuthFlags = c_uint;
pub const NM_SETTING_802_1X_AUTH_FLAGS_NONE: NMSetting8021xAuthFlags = 0;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE: NMSetting8021xAuthFlags = 1;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE: NMSetting8021xAuthFlags = 2;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE: NMSetting8021xAuthFlags = 4;
pub const NM_SETTING_802_1X_AUTH_FLAGS_ALL: NMSetting8021xAuthFlags = 7;

pub type NMSettingDcbFlags = c_uint;
pub const NM_SETTING_DCB_FLAG_NONE: NMSettingDcbFlags = 0;
pub const NM_SETTING_DCB_FLAG_ENABLE: NMSettingDcbFlags = 1;
pub const NM_SETTING_DCB_FLAG_ADVERTISE: NMSettingDcbFlags = 2;
pub const NM_SETTING_DCB_FLAG_WILLING: NMSettingDcbFlags = 4;

pub type NMSettingSecretFlags = c_uint;
pub const NM_SETTING_SECRET_FLAG_NONE: NMSettingSecretFlags = 0;
pub const NM_SETTING_SECRET_FLAG_AGENT_OWNED: NMSettingSecretFlags = 1;
pub const NM_SETTING_SECRET_FLAG_NOT_SAVED: NMSettingSecretFlags = 2;
pub const NM_SETTING_SECRET_FLAG_NOT_REQUIRED: NMSettingSecretFlags = 4;

pub type NMSettingWiredWakeOnLan = c_uint;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_PHY: NMSettingWiredWakeOnLan = 2;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST: NMSettingWiredWakeOnLan = 4;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST: NMSettingWiredWakeOnLan = 8;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST: NMSettingWiredWakeOnLan = 16;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_ARP: NMSettingWiredWakeOnLan = 32;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC: NMSettingWiredWakeOnLan = 64;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT: NMSettingWiredWakeOnLan = 1;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE: NMSettingWiredWakeOnLan = 32768;

pub type NMSettingWirelessSecurityWpsMethod = c_uint;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT: NMSettingWirelessSecurityWpsMethod = 0;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DISABLED: NMSettingWirelessSecurityWpsMethod = 1;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_AUTO: NMSettingWirelessSecurityWpsMethod = 2;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PBC: NMSettingWirelessSecurityWpsMethod = 4;
pub const NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PIN: NMSettingWirelessSecurityWpsMethod = 8;

pub type NMSettingWirelessWakeOnWLan = c_uint;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY: NMSettingWirelessWakeOnWLan = 2;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT: NMSettingWirelessWakeOnWLan = 4;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC: NMSettingWirelessWakeOnWLan = 8;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE: NMSettingWirelessWakeOnWLan = 16;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST: NMSettingWirelessWakeOnWLan = 32;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE: NMSettingWirelessWakeOnWLan = 64;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE: NMSettingWirelessWakeOnWLan = 128;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_TCP: NMSettingWirelessWakeOnWLan = 256;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL: NMSettingWirelessWakeOnWLan = 510;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT: NMSettingWirelessWakeOnWLan = 1;
pub const NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE: NMSettingWirelessWakeOnWLan = 32768;

pub type NMSettingsAddConnection2Flags = c_uint;
pub const NM_SETTINGS_ADD_CONNECTION2_FLAG_NONE: NMSettingsAddConnection2Flags = 0;
pub const NM_SETTINGS_ADD_CONNECTION2_FLAG_TO_DISK: NMSettingsAddConnection2Flags = 1;
pub const NM_SETTINGS_ADD_CONNECTION2_FLAG_IN_MEMORY: NMSettingsAddConnection2Flags = 2;
pub const NM_SETTINGS_ADD_CONNECTION2_FLAG_BLOCK_AUTOCONNECT: NMSettingsAddConnection2Flags = 32;

pub type NMSettingsConnectionFlags = c_uint;
pub const NM_SETTINGS_CONNECTION_FLAG_NONE: NMSettingsConnectionFlags = 0;
pub const NM_SETTINGS_CONNECTION_FLAG_UNSAVED: NMSettingsConnectionFlags = 1;
pub const NM_SETTINGS_CONNECTION_FLAG_NM_GENERATED: NMSettingsConnectionFlags = 2;
pub const NM_SETTINGS_CONNECTION_FLAG_VOLATILE: NMSettingsConnectionFlags = 4;

pub type NMSettingsUpdate2Flags = c_uint;
pub const NM_SETTINGS_UPDATE2_FLAG_NONE: NMSettingsUpdate2Flags = 0;
pub const NM_SETTINGS_UPDATE2_FLAG_TO_DISK: NMSettingsUpdate2Flags = 1;
pub const NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY: NMSettingsUpdate2Flags = 2;
pub const NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED: NMSettingsUpdate2Flags = 4;
pub const NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY: NMSettingsUpdate2Flags = 8;
pub const NM_SETTINGS_UPDATE2_FLAG_VOLATILE: NMSettingsUpdate2Flags = 16;
pub const NM_SETTINGS_UPDATE2_FLAG_BLOCK_AUTOCONNECT: NMSettingsUpdate2Flags = 32;
pub const NM_SETTINGS_UPDATE2_FLAG_NO_REAPPLY: NMSettingsUpdate2Flags = 64;

pub type NMTeamLinkWatcherArpPingFlags = c_uint;
pub const NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_ACTIVE: NMTeamLinkWatcherArpPingFlags = 2;
pub const NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_INACTIVE: NMTeamLinkWatcherArpPingFlags = 4;
pub const NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_SEND_ALWAYS: NMTeamLinkWatcherArpPingFlags = 8;

pub type NMVlanFlags = c_uint;
pub const NM_VLAN_FLAG_REORDER_HEADERS: NMVlanFlags = 1;
pub const NM_VLAN_FLAG_GVRP: NMVlanFlags = 2;
pub const NM_VLAN_FLAG_LOOSE_BINDING: NMVlanFlags = 4;
pub const NM_VLAN_FLAG_MVRP: NMVlanFlags = 8;

pub type NMVpnEditorPluginCapability = c_uint;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE: NMVpnEditorPluginCapability = 0;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT: NMVpnEditorPluginCapability = 1;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT: NMVpnEditorPluginCapability = 2;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6: NMVpnEditorPluginCapability = 4;

// Callbacks
pub type NMSecretAgentOldDeleteSecretsFunc = Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *mut glib::GError, gpointer)>;
pub type NMSecretAgentOldGetSecretsFunc = Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *mut glib::GVariant, *mut glib::GError, gpointer)>;
pub type NMSecretAgentOldSaveSecretsFunc = Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *mut glib::GError, gpointer)>;
pub type NMSettingClearSecretsWithFlagsFn = Option<unsafe extern "C" fn(*mut NMSetting, *const c_char, NMSettingSecretFlags, gpointer) -> gboolean>;
pub type NMSettingValueIterFn = Option<unsafe extern "C" fn(*mut NMSetting, *const c_char, *const gobject::GValue, gobject::GParamFlags, gpointer)>;
pub type NMUtilsCheckFilePredicate = Option<unsafe extern "C" fn(*const c_char, gpointer, *mut *mut glib::GError) -> gboolean>;
pub type NMUtilsFileSearchInPathsPredicate = Option<unsafe extern "C" fn(*const c_char, gpointer) -> gboolean>;
pub type NMVpnIterFunc = Option<unsafe extern "C" fn(*const c_char, *const c_char, gpointer)>;
pub type _NMConnectionForEachSecretFunc = Option<unsafe extern "C" fn(NMSettingSecretFlags, gpointer) -> gboolean>;

// Records
#[repr(C)]
pub struct _NMAccessPointClass(c_void);

pub type NMAccessPointClass = *mut _NMAccessPointClass;

#[repr(C)]
pub struct _NMActiveConnectionClass(c_void);

pub type NMActiveConnectionClass = *mut _NMActiveConnectionClass;

#[repr(C)]
pub struct NMBridgeVlan(c_void);

impl ::std::fmt::Debug for NMBridgeVlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMBridgeVlan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMCheckpointClass(c_void);

pub type NMCheckpointClass = *mut _NMCheckpointClass;

#[repr(C)]
pub struct _NMClientClass(c_void);

pub type NMClientClass = *mut _NMClientClass;

#[repr(C)]
pub struct NMConnectionInterface(c_void);

impl ::std::fmt::Debug for NMConnectionInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMConnectionInterface @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMDevice6LowpanClass(c_void);

pub type NMDevice6LowpanClass = *mut _NMDevice6LowpanClass;

#[repr(C)]
pub struct _NMDeviceAdslClass(c_void);

pub type NMDeviceAdslClass = *mut _NMDeviceAdslClass;

#[repr(C)]
pub struct _NMDeviceBondClass(c_void);

pub type NMDeviceBondClass = *mut _NMDeviceBondClass;

#[repr(C)]
pub struct _NMDeviceBridgeClass(c_void);

pub type NMDeviceBridgeClass = *mut _NMDeviceBridgeClass;

#[repr(C)]
pub struct _NMDeviceBtClass(c_void);

pub type NMDeviceBtClass = *mut _NMDeviceBtClass;

#[repr(C)]
pub struct _NMDeviceClass(c_void);

pub type NMDeviceClass = *mut _NMDeviceClass;

#[repr(C)]
pub struct _NMDeviceDummyClass(c_void);

pub type NMDeviceDummyClass = *mut _NMDeviceDummyClass;

#[repr(C)]
pub struct _NMDeviceEthernetClass(c_void);

pub type NMDeviceEthernetClass = *mut _NMDeviceEthernetClass;

#[repr(C)]
pub struct _NMDeviceGenericClass(c_void);

pub type NMDeviceGenericClass = *mut _NMDeviceGenericClass;

#[repr(C)]
pub struct _NMDeviceIPTunnelClass(c_void);

pub type NMDeviceIPTunnelClass = *mut _NMDeviceIPTunnelClass;

#[repr(C)]
pub struct _NMDeviceInfinibandClass(c_void);

pub type NMDeviceInfinibandClass = *mut _NMDeviceInfinibandClass;

#[repr(C)]
pub struct _NMDeviceMacsecClass(c_void);

pub type NMDeviceMacsecClass = *mut _NMDeviceMacsecClass;

#[repr(C)]
pub struct _NMDeviceMacvlanClass(c_void);

pub type NMDeviceMacvlanClass = *mut _NMDeviceMacvlanClass;

#[repr(C)]
pub struct _NMDeviceModemClass(c_void);

pub type NMDeviceModemClass = *mut _NMDeviceModemClass;

#[repr(C)]
pub struct _NMDeviceOlpcMeshClass(c_void);

pub type NMDeviceOlpcMeshClass = *mut _NMDeviceOlpcMeshClass;

#[repr(C)]
pub struct _NMDeviceOvsBridgeClass(c_void);

pub type NMDeviceOvsBridgeClass = *mut _NMDeviceOvsBridgeClass;

#[repr(C)]
pub struct _NMDeviceOvsInterfaceClass(c_void);

pub type NMDeviceOvsInterfaceClass = *mut _NMDeviceOvsInterfaceClass;

#[repr(C)]
pub struct _NMDeviceOvsPortClass(c_void);

pub type NMDeviceOvsPortClass = *mut _NMDeviceOvsPortClass;

#[repr(C)]
pub struct _NMDevicePppClass(c_void);

pub type NMDevicePppClass = *mut _NMDevicePppClass;

#[repr(C)]
pub struct _NMDeviceTeamClass(c_void);

pub type NMDeviceTeamClass = *mut _NMDeviceTeamClass;

#[repr(C)]
pub struct _NMDeviceTunClass(c_void);

pub type NMDeviceTunClass = *mut _NMDeviceTunClass;

#[repr(C)]
pub struct _NMDeviceVlanClass(c_void);

pub type NMDeviceVlanClass = *mut _NMDeviceVlanClass;

#[repr(C)]
pub struct _NMDeviceVrfClass(c_void);

pub type NMDeviceVrfClass = *mut _NMDeviceVrfClass;

#[repr(C)]
pub struct _NMDeviceVxlanClass(c_void);

pub type NMDeviceVxlanClass = *mut _NMDeviceVxlanClass;

#[repr(C)]
pub struct _NMDeviceWifiClass(c_void);

pub type NMDeviceWifiClass = *mut _NMDeviceWifiClass;

#[repr(C)]
pub struct _NMDeviceWifiP2PClass(c_void);

pub type NMDeviceWifiP2PClass = *mut _NMDeviceWifiP2PClass;

#[repr(C)]
pub struct _NMDeviceWimaxClass(c_void);

pub type NMDeviceWimaxClass = *mut _NMDeviceWimaxClass;

#[repr(C)]
pub struct _NMDeviceWireGuardClass(c_void);

pub type NMDeviceWireGuardClass = *mut _NMDeviceWireGuardClass;

#[repr(C)]
pub struct _NMDeviceWpanClass(c_void);

pub type NMDeviceWpanClass = *mut _NMDeviceWpanClass;

#[repr(C)]
pub struct _NMDhcpConfigClass(c_void);

pub type NMDhcpConfigClass = *mut _NMDhcpConfigClass;

#[repr(C)]
pub struct NMDnsEntry(c_void);

impl ::std::fmt::Debug for NMDnsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDnsEntry @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMIPAddress(c_void);

impl ::std::fmt::Debug for NMIPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPAddress @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMIPConfigClass(c_void);

pub type NMIPConfigClass = *mut _NMIPConfigClass;

#[repr(C)]
pub struct NMIPRoute(c_void);

impl ::std::fmt::Debug for NMIPRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPRoute @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMIPRoutingRule(c_void);

impl ::std::fmt::Debug for NMIPRoutingRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPRoutingRule @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMLldpNeighbor(c_void);

impl ::std::fmt::Debug for NMLldpNeighbor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMLldpNeighbor @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMObjectClass(c_void);

pub type NMObjectClass = *mut _NMObjectClass;

#[repr(C)]
pub struct _NMRemoteConnectionClass(c_void);

pub type NMRemoteConnectionClass = *mut _NMRemoteConnectionClass;

#[repr(C)]
pub struct NMSecretAgentOldClass(c_void);

impl ::std::fmt::Debug for NMSecretAgentOldClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSecretAgentOldClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSetting6LowpanClass(c_void);

pub type NMSetting6LowpanClass = *mut _NMSetting6LowpanClass;

#[repr(C)]
pub struct NMSetting8021xClass(c_void);

impl ::std::fmt::Debug for NMSetting8021xClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting8021xClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingAdslClass(c_void);

impl ::std::fmt::Debug for NMSettingAdslClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingAdslClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingBluetoothClass(c_void);

impl ::std::fmt::Debug for NMSettingBluetoothClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBluetoothClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingBondClass(c_void);

impl ::std::fmt::Debug for NMSettingBondClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBondClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingBridgeClass(c_void);

pub type NMSettingBridgeClass = *mut _NMSettingBridgeClass;

#[repr(C)]
pub struct NMSettingBridgePortClass(c_void);

impl ::std::fmt::Debug for NMSettingBridgePortClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBridgePortClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingCdmaClass(c_void);

impl ::std::fmt::Debug for NMSettingCdmaClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingCdmaClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingClass(c_void);

impl ::std::fmt::Debug for NMSettingClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingConnectionClass(c_void);

impl ::std::fmt::Debug for NMSettingConnectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingConnectionClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingDcbClass(c_void);

impl ::std::fmt::Debug for NMSettingDcbClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDcbClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingDummyClass(c_void);

impl ::std::fmt::Debug for NMSettingDummyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDummyClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingEthtoolClass(c_void);

pub type NMSettingEthtoolClass = *mut _NMSettingEthtoolClass;

#[repr(C)]
pub struct NMSettingGenericClass(c_void);

impl ::std::fmt::Debug for NMSettingGenericClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGenericClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingGsmClass(c_void);

impl ::std::fmt::Debug for NMSettingGsmClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGsmClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingIP4ConfigClass(c_void);

impl ::std::fmt::Debug for NMSettingIP4ConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP4ConfigClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingIP6ConfigClass(c_void);

impl ::std::fmt::Debug for NMSettingIP6ConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP6ConfigClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingIPConfigClass(c_void);

impl ::std::fmt::Debug for NMSettingIPConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPConfigClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingIPTunnelClass(c_void);

impl ::std::fmt::Debug for NMSettingIPTunnelClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPTunnelClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingInfinibandClass(c_void);

impl ::std::fmt::Debug for NMSettingInfinibandClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingInfinibandClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingMacsecClass(c_void);

impl ::std::fmt::Debug for NMSettingMacsecClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacsecClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingMacvlanClass(c_void);

impl ::std::fmt::Debug for NMSettingMacvlanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacvlanClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingMatchClass(c_void);

pub type NMSettingMatchClass = *mut _NMSettingMatchClass;

#[repr(C)]
pub struct NMSettingOlpcMeshClass(c_void);

impl ::std::fmt::Debug for NMSettingOlpcMeshClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOlpcMeshClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingOvsBridgeClass(c_void);

pub type NMSettingOvsBridgeClass = *mut _NMSettingOvsBridgeClass;

#[repr(C)]
pub struct _NMSettingOvsDpdkClass(c_void);

pub type NMSettingOvsDpdkClass = *mut _NMSettingOvsDpdkClass;

#[repr(C)]
pub struct _NMSettingOvsInterfaceClass(c_void);

pub type NMSettingOvsInterfaceClass = *mut _NMSettingOvsInterfaceClass;

#[repr(C)]
pub struct _NMSettingOvsPatchClass(c_void);

pub type NMSettingOvsPatchClass = *mut _NMSettingOvsPatchClass;

#[repr(C)]
pub struct _NMSettingOvsPortClass(c_void);

pub type NMSettingOvsPortClass = *mut _NMSettingOvsPortClass;

#[repr(C)]
pub struct NMSettingPppClass(c_void);

impl ::std::fmt::Debug for NMSettingPppClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPppClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingPppoeClass(c_void);

impl ::std::fmt::Debug for NMSettingPppoeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPppoeClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingProxyClass(c_void);

impl ::std::fmt::Debug for NMSettingProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingProxyClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingSerialClass(c_void);

impl ::std::fmt::Debug for NMSettingSerialClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingSerialClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingSriovClass(c_void);

pub type NMSettingSriovClass = *mut _NMSettingSriovClass;

#[repr(C)]
pub struct _NMSettingTCConfigClass(c_void);

pub type NMSettingTCConfigClass = *mut _NMSettingTCConfigClass;

#[repr(C)]
pub struct NMSettingTeamClass(c_void);

impl ::std::fmt::Debug for NMSettingTeamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeamClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingTeamPortClass(c_void);

impl ::std::fmt::Debug for NMSettingTeamPortClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeamPortClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingTunClass(c_void);

impl ::std::fmt::Debug for NMSettingTunClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTunClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingUserClass(c_void);

pub type NMSettingUserClass = *mut _NMSettingUserClass;

#[repr(C)]
pub struct NMSettingVlanClass(c_void);

impl ::std::fmt::Debug for NMSettingVlanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVlanClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingVpnClass(c_void);

impl ::std::fmt::Debug for NMSettingVpnClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVpnClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingVrfClass(c_void);

pub type NMSettingVrfClass = *mut _NMSettingVrfClass;

#[repr(C)]
pub struct NMSettingVxlanClass(c_void);

impl ::std::fmt::Debug for NMSettingVxlanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVxlanClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingWifiP2PClass(c_void);

pub type NMSettingWifiP2PClass = *mut _NMSettingWifiP2PClass;

#[repr(C)]
pub struct NMSettingWimaxClass(c_void);

impl ::std::fmt::Debug for NMSettingWimaxClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWimaxClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingWireGuardClass(c_void);

pub type NMSettingWireGuardClass = *mut _NMSettingWireGuardClass;

#[repr(C)]
pub struct NMSettingWiredClass(c_void);

impl ::std::fmt::Debug for NMSettingWiredClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWiredClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingWirelessClass(c_void);

impl ::std::fmt::Debug for NMSettingWirelessClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWirelessClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingWirelessSecurityClass(c_void);

impl ::std::fmt::Debug for NMSettingWirelessSecurityClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWirelessSecurityClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMSettingWpanClass(c_void);

pub type NMSettingWpanClass = *mut _NMSettingWpanClass;

#[repr(C)]
pub struct NMSimpleConnectionClass(c_void);

impl ::std::fmt::Debug for NMSimpleConnectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSimpleConnectionClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSriovVF(c_void);

impl ::std::fmt::Debug for NMSriovVF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSriovVF @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMTCQdisc(c_void);

impl ::std::fmt::Debug for NMTCQdisc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMTCQdisc @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMTCTfilter(c_void);

impl ::std::fmt::Debug for NMTCTfilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMTCTfilter @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMTeamLinkWatcher(c_void);

impl ::std::fmt::Debug for NMTeamLinkWatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMTeamLinkWatcher @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMVariantAttributeSpec(c_void);

pub type NMVariantAttributeSpec = *mut _NMVariantAttributeSpec;

#[repr(C)]
pub struct _NMVpnConnectionClass(c_void);

pub type NMVpnConnectionClass = *mut _NMVpnConnectionClass;

#[repr(C)]
pub struct NMVpnEditorInterface(c_void);

impl ::std::fmt::Debug for NMVpnEditorInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnEditorInterface @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMVpnEditorPluginInterface(c_void);

impl ::std::fmt::Debug for NMVpnEditorPluginInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnEditorPluginInterface @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMVpnEditorPluginVT(c_void);

pub type NMVpnEditorPluginVT = *mut _NMVpnEditorPluginVT;

#[repr(C)]
pub struct _NMVpnPluginInfoClass(c_void);

pub type NMVpnPluginInfoClass = *mut _NMVpnPluginInfoClass;

#[repr(C)]
pub struct NMVpnPluginOldClass(c_void);

impl ::std::fmt::Debug for NMVpnPluginOldClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginOldClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMVpnServicePluginClass(c_void);

impl ::std::fmt::Debug for NMVpnServicePluginClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnServicePluginClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct _NMWifiP2PPeerClass(c_void);

pub type NMWifiP2PPeerClass = *mut _NMWifiP2PPeerClass;

#[repr(C)]
pub struct _NMWimaxNspClass(c_void);

pub type NMWimaxNspClass = *mut _NMWimaxNspClass;

#[repr(C)]
pub struct NMWireGuardPeer(c_void);

impl ::std::fmt::Debug for NMWireGuardPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMWireGuardPeer @ {:?}", self as *const _))
         .finish()
    }
}

// Classes
#[repr(C)]
pub struct NMAccessPoint(c_void);

impl ::std::fmt::Debug for NMAccessPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMAccessPoint @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMActiveConnection(c_void);

impl ::std::fmt::Debug for NMActiveConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMActiveConnection @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMCheckpoint(c_void);

impl ::std::fmt::Debug for NMCheckpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMCheckpoint @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMClient(c_void);

impl ::std::fmt::Debug for NMClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMClient @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDevice(c_void);

impl ::std::fmt::Debug for NMDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDevice @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDevice6Lowpan(c_void);

impl ::std::fmt::Debug for NMDevice6Lowpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDevice6Lowpan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceAdsl(c_void);

impl ::std::fmt::Debug for NMDeviceAdsl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceAdsl @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceBond(c_void);

impl ::std::fmt::Debug for NMDeviceBond {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBond @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceBridge(c_void);

impl ::std::fmt::Debug for NMDeviceBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBridge @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceBt(c_void);

impl ::std::fmt::Debug for NMDeviceBt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBt @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceDummy(c_void);

impl ::std::fmt::Debug for NMDeviceDummy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceDummy @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceEthernet(c_void);

impl ::std::fmt::Debug for NMDeviceEthernet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceEthernet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceGeneric(c_void);

impl ::std::fmt::Debug for NMDeviceGeneric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceGeneric @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceIPTunnel(c_void);

impl ::std::fmt::Debug for NMDeviceIPTunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceIPTunnel @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceInfiniband(c_void);

impl ::std::fmt::Debug for NMDeviceInfiniband {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceInfiniband @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceMacsec(c_void);

impl ::std::fmt::Debug for NMDeviceMacsec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceMacsec @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceMacvlan(c_void);

impl ::std::fmt::Debug for NMDeviceMacvlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceMacvlan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceModem(c_void);

impl ::std::fmt::Debug for NMDeviceModem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceModem @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceOlpcMesh(c_void);

impl ::std::fmt::Debug for NMDeviceOlpcMesh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOlpcMesh @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceOvsBridge(c_void);

impl ::std::fmt::Debug for NMDeviceOvsBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOvsBridge @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceOvsInterface(c_void);

impl ::std::fmt::Debug for NMDeviceOvsInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOvsInterface @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceOvsPort(c_void);

impl ::std::fmt::Debug for NMDeviceOvsPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOvsPort @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDevicePpp(c_void);

impl ::std::fmt::Debug for NMDevicePpp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDevicePpp @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceTeam(c_void);

impl ::std::fmt::Debug for NMDeviceTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceTeam @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceTun(c_void);

impl ::std::fmt::Debug for NMDeviceTun {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceTun @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceVlan(c_void);

impl ::std::fmt::Debug for NMDeviceVlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVlan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceVrf(c_void);

impl ::std::fmt::Debug for NMDeviceVrf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVrf @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceVxlan(c_void);

impl ::std::fmt::Debug for NMDeviceVxlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVxlan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceWifi(c_void);

impl ::std::fmt::Debug for NMDeviceWifi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWifi @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceWifiP2P(c_void);

impl ::std::fmt::Debug for NMDeviceWifiP2P {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWifiP2P @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceWimax(c_void);

impl ::std::fmt::Debug for NMDeviceWimax {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWimax @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDeviceWireGuard(c_void);

impl ::std::fmt::Debug for NMDeviceWireGuard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWireGuard @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMDhcpConfig(c_void);

impl ::std::fmt::Debug for NMDhcpConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDhcpConfig @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMIPConfig(c_void);

impl ::std::fmt::Debug for NMIPConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPConfig @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMObject(c_void);

impl ::std::fmt::Debug for NMObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMObject @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMRemoteConnection(c_void);

impl ::std::fmt::Debug for NMRemoteConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMRemoteConnection @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSecretAgentOld(c_void);

impl ::std::fmt::Debug for NMSecretAgentOld {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSecretAgentOld @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSetting(c_void);

impl ::std::fmt::Debug for NMSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSetting6Lowpan(c_void);

impl ::std::fmt::Debug for NMSetting6Lowpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting6Lowpan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSetting8021x(c_void);

impl ::std::fmt::Debug for NMSetting8021x {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting8021x @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingAdsl(c_void);

impl ::std::fmt::Debug for NMSettingAdsl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingAdsl @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingBluetooth(c_void);

impl ::std::fmt::Debug for NMSettingBluetooth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBluetooth @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingBond(c_void);

impl ::std::fmt::Debug for NMSettingBond {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBond @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingBridge(c_void);

impl ::std::fmt::Debug for NMSettingBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBridge @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingBridgePort(c_void);

impl ::std::fmt::Debug for NMSettingBridgePort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBridgePort @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingCdma(c_void);

impl ::std::fmt::Debug for NMSettingCdma {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingCdma @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingConnection(c_void);

impl ::std::fmt::Debug for NMSettingConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingConnection @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingDcb(c_void);

impl ::std::fmt::Debug for NMSettingDcb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDcb @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingDummy(c_void);

impl ::std::fmt::Debug for NMSettingDummy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDummy @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingEthtool(c_void);

impl ::std::fmt::Debug for NMSettingEthtool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingEthtool @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingGeneric(c_void);

impl ::std::fmt::Debug for NMSettingGeneric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGeneric @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingGsm(c_void);

impl ::std::fmt::Debug for NMSettingGsm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGsm @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingIP4Config(c_void);

impl ::std::fmt::Debug for NMSettingIP4Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP4Config @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingIP6Config(c_void);

impl ::std::fmt::Debug for NMSettingIP6Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP6Config @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingIPConfig(c_void);

impl ::std::fmt::Debug for NMSettingIPConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPConfig @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingIPTunnel(c_void);

impl ::std::fmt::Debug for NMSettingIPTunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPTunnel @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingInfiniband(c_void);

impl ::std::fmt::Debug for NMSettingInfiniband {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingInfiniband @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingMacsec(c_void);

impl ::std::fmt::Debug for NMSettingMacsec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacsec @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingMacvlan(c_void);

impl ::std::fmt::Debug for NMSettingMacvlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacvlan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingMatch(c_void);

impl ::std::fmt::Debug for NMSettingMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMatch @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingOlpcMesh(c_void);

impl ::std::fmt::Debug for NMSettingOlpcMesh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOlpcMesh @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingOvsBridge(c_void);

impl ::std::fmt::Debug for NMSettingOvsBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsBridge @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingOvsDpdk(c_void);

impl ::std::fmt::Debug for NMSettingOvsDpdk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsDpdk @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingOvsInterface(c_void);

impl ::std::fmt::Debug for NMSettingOvsInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsInterface @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingOvsPatch(c_void);

impl ::std::fmt::Debug for NMSettingOvsPatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsPatch @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingOvsPort(c_void);

impl ::std::fmt::Debug for NMSettingOvsPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOvsPort @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingPpp(c_void);

impl ::std::fmt::Debug for NMSettingPpp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPpp @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingPppoe(c_void);

impl ::std::fmt::Debug for NMSettingPppoe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPppoe @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingProxy(c_void);

impl ::std::fmt::Debug for NMSettingProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingProxy @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingSerial(c_void);

impl ::std::fmt::Debug for NMSettingSerial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingSerial @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingSriov(c_void);

impl ::std::fmt::Debug for NMSettingSriov {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingSriov @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingTCConfig(c_void);

impl ::std::fmt::Debug for NMSettingTCConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTCConfig @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingTeam(c_void);

impl ::std::fmt::Debug for NMSettingTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeam @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingTeamPort(c_void);

impl ::std::fmt::Debug for NMSettingTeamPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeamPort @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingTun(c_void);

impl ::std::fmt::Debug for NMSettingTun {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTun @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingUser(c_void);

impl ::std::fmt::Debug for NMSettingUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingUser @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingVlan(c_void);

impl ::std::fmt::Debug for NMSettingVlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVlan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingVpn(c_void);

impl ::std::fmt::Debug for NMSettingVpn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVpn @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingVrf(c_void);

impl ::std::fmt::Debug for NMSettingVrf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVrf @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingVxlan(c_void);

impl ::std::fmt::Debug for NMSettingVxlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVxlan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingWifiP2P(c_void);

impl ::std::fmt::Debug for NMSettingWifiP2P {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWifiP2P @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingWimax(c_void);

impl ::std::fmt::Debug for NMSettingWimax {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWimax @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingWireGuard(c_void);

impl ::std::fmt::Debug for NMSettingWireGuard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWireGuard @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingWired(c_void);

impl ::std::fmt::Debug for NMSettingWired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWired @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingWireless(c_void);

impl ::std::fmt::Debug for NMSettingWireless {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWireless @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingWirelessSecurity(c_void);

impl ::std::fmt::Debug for NMSettingWirelessSecurity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWirelessSecurity @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingWpan(c_void);

impl ::std::fmt::Debug for NMSettingWpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWpan @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMSimpleConnection(c_void);

impl ::std::fmt::Debug for NMSimpleConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSimpleConnection @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMVpnConnection(c_void);

impl ::std::fmt::Debug for NMVpnConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnConnection @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMVpnPluginInfo(c_void);

impl ::std::fmt::Debug for NMVpnPluginInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginInfo @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMVpnPluginOld(c_void);

impl ::std::fmt::Debug for NMVpnPluginOld {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginOld @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMVpnServicePlugin(c_void);

impl ::std::fmt::Debug for NMVpnServicePlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnServicePlugin @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMWifiP2PPeer(c_void);

impl ::std::fmt::Debug for NMWifiP2PPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMWifiP2PPeer @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMWimaxNsp(c_void);

impl ::std::fmt::Debug for NMWimaxNsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMWimaxNsp @ {:?}", self as *const _))
         .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct NMConnection(c_void);

impl ::std::fmt::Debug for NMConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "NMConnection @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct NMVpnEditor(c_void);

impl ::std::fmt::Debug for NMVpnEditor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "NMVpnEditor @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct NMVpnEditorPlugin(c_void);

impl ::std::fmt::Debug for NMVpnEditorPlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "NMVpnEditorPlugin @ {:?}", self as *const _)
    }
}


extern "C" {

    //=========================================================================
    // NM80211Mode
    //=========================================================================
    pub fn nm_802_11_mode_get_type() -> GType;

    //=========================================================================
    // NMActiveConnectionState
    //=========================================================================
    pub fn nm_active_connection_state_get_type() -> GType;

    //=========================================================================
    // NMActiveConnectionStateReason
    //=========================================================================
    pub fn nm_active_connection_state_reason_get_type() -> GType;

    //=========================================================================
    // NMAgentManagerError
    //=========================================================================
    pub fn nm_agent_manager_error_get_type() -> GType;
    pub fn nm_agent_manager_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMCapability
    //=========================================================================
    pub fn nm_capability_get_type() -> GType;

    //=========================================================================
    // NMClientError
    //=========================================================================
    pub fn nm_client_error_get_type() -> GType;
    pub fn nm_client_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMClientPermission
    //=========================================================================
    pub fn nm_client_permission_get_type() -> GType;

    //=========================================================================
    // NMClientPermissionResult
    //=========================================================================
    pub fn nm_client_permission_result_get_type() -> GType;

    //=========================================================================
    // NMConnectionError
    //=========================================================================
    pub fn nm_connection_error_get_type() -> GType;
    pub fn nm_connection_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMConnectionMultiConnect
    //=========================================================================
    pub fn nm_connection_multi_connect_get_type() -> GType;

    //=========================================================================
    // NMConnectivityState
    //=========================================================================
    pub fn nm_connectivity_state_get_type() -> GType;

    //=========================================================================
    // NMCryptoError
    //=========================================================================
    pub fn nm_crypto_error_get_type() -> GType;
    pub fn nm_crypto_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMDeviceError
    //=========================================================================
    pub fn nm_device_error_get_type() -> GType;
    pub fn nm_device_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMDeviceState
    //=========================================================================
    pub fn nm_device_state_get_type() -> GType;

    //=========================================================================
    // NMDeviceStateReason
    //=========================================================================
    pub fn nm_device_state_reason_get_type() -> GType;

    //=========================================================================
    // NMDeviceType
    //=========================================================================
    pub fn nm_device_type_get_type() -> GType;

    //=========================================================================
    // NMIPTunnelMode
    //=========================================================================
    pub fn nm_ip_tunnel_mode_get_type() -> GType;

    //=========================================================================
    // NMManagerError
    //=========================================================================
    pub fn nm_manager_error_get_type() -> GType;
    pub fn nm_manager_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMMetered
    //=========================================================================
    pub fn nm_metered_get_type() -> GType;

    //=========================================================================
    // NMSecretAgentError
    //=========================================================================
    pub fn nm_secret_agent_error_get_type() -> GType;
    pub fn nm_secret_agent_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMSetting8021xCKFormat
    //=========================================================================
    pub fn nm_setting_802_1x_ck_format_get_type() -> GType;

    //=========================================================================
    // NMSetting8021xCKScheme
    //=========================================================================
    pub fn nm_setting_802_1x_ck_scheme_get_type() -> GType;

    //=========================================================================
    // NMSettingCompareFlags
    //=========================================================================
    pub fn nm_setting_compare_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionAutoconnectSlaves
    //=========================================================================
    pub fn nm_setting_connection_autoconnect_slaves_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionLldp
    //=========================================================================
    pub fn nm_setting_connection_lldp_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionLlmnr
    //=========================================================================
    pub fn nm_setting_connection_llmnr_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionMdns
    //=========================================================================
    pub fn nm_setting_connection_mdns_get_type() -> GType;

    //=========================================================================
    // NMSettingDiffResult
    //=========================================================================
    pub fn nm_setting_diff_result_get_type() -> GType;

    //=========================================================================
    // NMSettingIP6ConfigAddrGenMode
    //=========================================================================
    pub fn nm_setting_ip6_config_addr_gen_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingIP6ConfigPrivacy
    //=========================================================================
    pub fn nm_setting_ip6_config_privacy_get_type() -> GType;

    //=========================================================================
    // NMSettingMacRandomization
    //=========================================================================
    pub fn nm_setting_mac_randomization_get_type() -> GType;

    //=========================================================================
    // NMSettingMacsecMode
    //=========================================================================
    pub fn nm_setting_macsec_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingMacsecValidation
    //=========================================================================
    pub fn nm_setting_macsec_validation_get_type() -> GType;

    //=========================================================================
    // NMSettingMacvlanMode
    //=========================================================================
    pub fn nm_setting_macvlan_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingProxyMethod
    //=========================================================================
    pub fn nm_setting_proxy_method_get_type() -> GType;

    //=========================================================================
    // NMSettingSerialParity
    //=========================================================================
    pub fn nm_setting_serial_parity_get_type() -> GType;

    //=========================================================================
    // NMSettingTunMode
    //=========================================================================
    pub fn nm_setting_tun_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessPowersave
    //=========================================================================
    pub fn nm_setting_wireless_powersave_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessSecurityFils
    //=========================================================================
    pub fn nm_setting_wireless_security_fils_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessSecurityPmf
    //=========================================================================
    pub fn nm_setting_wireless_security_pmf_get_type() -> GType;

    //=========================================================================
    // NMSettingsError
    //=========================================================================
    pub fn nm_settings_error_get_type() -> GType;
    pub fn nm_settings_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMSriovVFVlanProtocol
    //=========================================================================
    pub fn nm_sriov_vf_vlan_protocol_get_type() -> GType;

    //=========================================================================
    // NMState
    //=========================================================================
    pub fn nm_state_get_type() -> GType;

    //=========================================================================
    // NMTernary
    //=========================================================================
    pub fn nm_ternary_get_type() -> GType;

    //=========================================================================
    // NMUtilsSecurityType
    //=========================================================================
    pub fn nm_utils_security_type_get_type() -> GType;

    //=========================================================================
    // NMVlanPriorityMap
    //=========================================================================
    pub fn nm_vlan_priority_map_get_type() -> GType;

    //=========================================================================
    // NMVpnConnectionState
    //=========================================================================
    pub fn nm_vpn_connection_state_get_type() -> GType;

    //=========================================================================
    // NMVpnConnectionStateReason
    //=========================================================================
    pub fn nm_vpn_connection_state_reason_get_type() -> GType;

    //=========================================================================
    // NMVpnPluginError
    //=========================================================================
    pub fn nm_vpn_plugin_error_get_type() -> GType;
    pub fn nm_vpn_plugin_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMVpnPluginFailure
    //=========================================================================
    pub fn nm_vpn_plugin_failure_get_type() -> GType;

    //=========================================================================
    // NMVpnServiceState
    //=========================================================================
    pub fn nm_vpn_service_state_get_type() -> GType;

    //=========================================================================
    // NMWepKeyType
    //=========================================================================
    pub fn nm_wep_key_type_get_type() -> GType;

    //=========================================================================
    // NMWimaxNspNetworkType
    //=========================================================================
    pub fn nm_wimax_nsp_network_type_get_type() -> GType;

    //=========================================================================
    // NM80211ApFlags
    //=========================================================================
    pub fn nm_802_11_ap_flags_get_type() -> GType;

    //=========================================================================
    // NM80211ApSecurityFlags
    //=========================================================================
    pub fn nm_802_11_ap_security_flags_get_type() -> GType;

    //=========================================================================
    // NMActivationStateFlags
    //=========================================================================
    pub fn nm_activation_state_flags_get_type() -> GType;

    //=========================================================================
    // NMBluetoothCapabilities
    //=========================================================================
    pub fn nm_bluetooth_capabilities_get_type() -> GType;

    //=========================================================================
    // NMCheckpointCreateFlags
    //=========================================================================
    pub fn nm_checkpoint_create_flags_get_type() -> GType;

    //=========================================================================
    // NMClientInstanceFlags
    //=========================================================================
    pub fn nm_client_instance_flags_get_type() -> GType;

    //=========================================================================
    // NMConnectionSerializationFlags
    //=========================================================================
    pub fn nm_connection_serialization_flags_get_type() -> GType;

    //=========================================================================
    // NMDeviceCapabilities
    //=========================================================================
    pub fn nm_device_capabilities_get_type() -> GType;

    //=========================================================================
    // NMDeviceInterfaceFlags
    //=========================================================================
    pub fn nm_device_interface_flags_get_type() -> GType;

    //=========================================================================
    // NMDeviceModemCapabilities
    //=========================================================================
    pub fn nm_device_modem_capabilities_get_type() -> GType;

    //=========================================================================
    // NMDeviceWifiCapabilities
    //=========================================================================
    pub fn nm_device_wifi_capabilities_get_type() -> GType;

    //=========================================================================
    // NMDhcpHostnameFlags
    //=========================================================================
    pub fn nm_dhcp_hostname_flags_get_type() -> GType;

    //=========================================================================
    // NMIPAddressCmpFlags
    //=========================================================================
    pub fn nm_ip_address_cmp_flags_get_type() -> GType;

    //=========================================================================
    // NMIPRoutingRuleAsStringFlags
    //=========================================================================
    pub fn nm_ip_routing_rule_as_string_flags_get_type() -> GType;

    //=========================================================================
    // NMIPTunnelFlags
    //=========================================================================
    pub fn nm_ip_tunnel_flags_get_type() -> GType;

    //=========================================================================
    // NMManagerReloadFlags
    //=========================================================================
    pub fn nm_manager_reload_flags_get_type() -> GType;

    //=========================================================================
    // NMSecretAgentCapabilities
    //=========================================================================
    pub fn nm_secret_agent_capabilities_get_type() -> GType;

    //=========================================================================
    // NMSecretAgentGetSecretsFlags
    //=========================================================================
    pub fn nm_secret_agent_get_secrets_flags_get_type() -> GType;

    //=========================================================================
    // NMSetting8021xAuthFlags
    //=========================================================================
    pub fn nm_setting_802_1x_auth_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingDcbFlags
    //=========================================================================
    pub fn nm_setting_dcb_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingSecretFlags
    //=========================================================================
    pub fn nm_setting_secret_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingWiredWakeOnLan
    //=========================================================================
    pub fn nm_setting_wired_wake_on_lan_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessSecurityWpsMethod
    //=========================================================================
    pub fn nm_setting_wireless_security_wps_method_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessWakeOnWLan
    //=========================================================================
    pub fn nm_setting_wireless_wake_on_wlan_get_type() -> GType;

    //=========================================================================
    // NMSettingsAddConnection2Flags
    //=========================================================================
    pub fn nm_settings_add_connection2_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingsConnectionFlags
    //=========================================================================
    pub fn nm_settings_connection_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingsUpdate2Flags
    //=========================================================================
    pub fn nm_settings_update2_flags_get_type() -> GType;

    //=========================================================================
    // NMTeamLinkWatcherArpPingFlags
    //=========================================================================
    pub fn nm_team_link_watcher_arp_ping_flags_get_type() -> GType;

    //=========================================================================
    // NMVlanFlags
    //=========================================================================
    pub fn nm_vlan_flags_get_type() -> GType;

    //=========================================================================
    // NMVpnEditorPluginCapability
    //=========================================================================
    pub fn nm_vpn_editor_plugin_capability_get_type() -> GType;

    //=========================================================================
    // NMBridgeVlan
    //=========================================================================
    pub fn nm_bridge_vlan_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_new(vid_start: u16, vid_end: u16) -> *mut NMBridgeVlan;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_cmp(a: *const NMBridgeVlan, b: *const NMBridgeVlan) -> c_int;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_get_vid_range(vlan: *const NMBridgeVlan, vid_start: *mut u16, vid_end: *mut u16) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_is_pvid(vlan: *const NMBridgeVlan) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_is_sealed(vlan: *const NMBridgeVlan) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_is_untagged(vlan: *const NMBridgeVlan) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_new_clone(vlan: *const NMBridgeVlan) -> *mut NMBridgeVlan;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_ref(vlan: *mut NMBridgeVlan) -> *mut NMBridgeVlan;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_seal(vlan: *mut NMBridgeVlan);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_set_pvid(vlan: *mut NMBridgeVlan, value: gboolean);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_set_untagged(vlan: *mut NMBridgeVlan, value: gboolean);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_to_str(vlan: *const NMBridgeVlan, error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_unref(vlan: *mut NMBridgeVlan);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_bridge_vlan_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMBridgeVlan;

    //=========================================================================
    // NMDnsEntry
    //=========================================================================
    pub fn nm_dns_entry_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_domains(entry: *mut NMDnsEntry) -> *const *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_interface(entry: *mut NMDnsEntry) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_nameservers(entry: *mut NMDnsEntry) -> *const *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_priority(entry: *mut NMDnsEntry) -> c_int;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_vpn(entry: *mut NMDnsEntry) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_unref(entry: *mut NMDnsEntry);

    //=========================================================================
    // NMIPAddress
    //=========================================================================
    pub fn nm_ip_address_get_type() -> GType;
    pub fn nm_ip_address_new(family: c_int, addr: *const c_char, prefix: c_uint, error: *mut *mut glib::GError) -> *mut NMIPAddress;
    pub fn nm_ip_address_new_binary(family: c_int, addr: gconstpointer, prefix: c_uint, error: *mut *mut glib::GError) -> *mut NMIPAddress;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_ip_address_cmp_full(a: *const NMIPAddress, b: *const NMIPAddress, cmp_flags: NMIPAddressCmpFlags) -> c_int;
    pub fn nm_ip_address_dup(address: *mut NMIPAddress) -> *mut NMIPAddress;
    pub fn nm_ip_address_equal(address: *mut NMIPAddress, other: *mut NMIPAddress) -> gboolean;
    pub fn nm_ip_address_get_address(address: *mut NMIPAddress) -> *const c_char;
    pub fn nm_ip_address_get_address_binary(address: *mut NMIPAddress, addr: gpointer);
    pub fn nm_ip_address_get_attribute(address: *mut NMIPAddress, name: *const c_char) -> *mut glib::GVariant;
    pub fn nm_ip_address_get_family(address: *mut NMIPAddress) -> c_int;
    pub fn nm_ip_address_get_prefix(address: *mut NMIPAddress) -> c_uint;
    pub fn nm_ip_address_ref(address: *mut NMIPAddress);
    pub fn nm_ip_address_set_address(address: *mut NMIPAddress, addr: *const c_char);
    pub fn nm_ip_address_set_address_binary(address: *mut NMIPAddress, addr: gconstpointer);
    pub fn nm_ip_address_set_attribute(address: *mut NMIPAddress, name: *const c_char, value: *mut glib::GVariant);
    pub fn nm_ip_address_set_prefix(address: *mut NMIPAddress, prefix: c_uint);
    pub fn nm_ip_address_unref(address: *mut NMIPAddress);

    //=========================================================================
    // NMIPRoute
    //=========================================================================
    pub fn nm_ip_route_get_type() -> GType;
    pub fn nm_ip_route_new(family: c_int, dest: *const c_char, prefix: c_uint, next_hop: *const c_char, metric: i64, error: *mut *mut glib::GError) -> *mut NMIPRoute;
    pub fn nm_ip_route_new_binary(family: c_int, dest: gconstpointer, prefix: c_uint, next_hop: gconstpointer, metric: i64, error: *mut *mut glib::GError) -> *mut NMIPRoute;
    pub fn nm_ip_route_dup(route: *mut NMIPRoute) -> *mut NMIPRoute;
    pub fn nm_ip_route_equal(route: *mut NMIPRoute, other: *mut NMIPRoute) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_ip_route_equal_full(route: *mut NMIPRoute, other: *mut NMIPRoute, cmp_flags: c_uint) -> gboolean;
    pub fn nm_ip_route_get_attribute(route: *mut NMIPRoute, name: *const c_char) -> *mut glib::GVariant;
    pub fn nm_ip_route_get_dest(route: *mut NMIPRoute) -> *const c_char;
    pub fn nm_ip_route_get_dest_binary(route: *mut NMIPRoute, dest: gpointer);
    pub fn nm_ip_route_get_family(route: *mut NMIPRoute) -> c_int;
    pub fn nm_ip_route_get_metric(route: *mut NMIPRoute) -> i64;
    pub fn nm_ip_route_get_next_hop(route: *mut NMIPRoute) -> *const c_char;
    pub fn nm_ip_route_get_next_hop_binary(route: *mut NMIPRoute, next_hop: gpointer) -> gboolean;
    pub fn nm_ip_route_get_prefix(route: *mut NMIPRoute) -> c_uint;
    pub fn nm_ip_route_ref(route: *mut NMIPRoute);
    pub fn nm_ip_route_set_attribute(route: *mut NMIPRoute, name: *const c_char, value: *mut glib::GVariant);
    pub fn nm_ip_route_set_dest(route: *mut NMIPRoute, dest: *const c_char);
    pub fn nm_ip_route_set_dest_binary(route: *mut NMIPRoute, dest: gconstpointer);
    pub fn nm_ip_route_set_metric(route: *mut NMIPRoute, metric: i64);
    pub fn nm_ip_route_set_next_hop(route: *mut NMIPRoute, next_hop: *const c_char);
    pub fn nm_ip_route_set_next_hop_binary(route: *mut NMIPRoute, next_hop: gconstpointer);
    pub fn nm_ip_route_set_prefix(route: *mut NMIPRoute, prefix: c_uint);
    pub fn nm_ip_route_unref(route: *mut NMIPRoute);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_ip_route_attribute_validate(name: *const c_char, value: *mut glib::GVariant, family: c_int, known: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_ip_route_get_variant_attribute_spec() -> *const *const NMVariantAttributeSpec;

    //=========================================================================
    // NMIPRoutingRule
    //=========================================================================
    pub fn nm_ip_routing_rule_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_new(addr_family: c_int) -> *mut NMIPRoutingRule;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_cmp(rule: *const NMIPRoutingRule, other: *const NMIPRoutingRule) -> c_int;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_action(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_addr_family(self_: *const NMIPRoutingRule) -> c_int;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_destination_port_end(self_: *const NMIPRoutingRule) -> u16;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_destination_port_start(self_: *const NMIPRoutingRule) -> u16;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_from(self_: *const NMIPRoutingRule) -> *const c_char;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_from_len(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_fwmark(self_: *const NMIPRoutingRule) -> u32;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_fwmask(self_: *const NMIPRoutingRule) -> u32;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_iifname(self_: *const NMIPRoutingRule) -> *const c_char;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_invert(self_: *const NMIPRoutingRule) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_ipproto(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_oifname(self_: *const NMIPRoutingRule) -> *const c_char;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_priority(self_: *const NMIPRoutingRule) -> i64;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_source_port_end(self_: *const NMIPRoutingRule) -> u16;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_source_port_start(self_: *const NMIPRoutingRule) -> u16;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_suppress_prefixlength(self_: *const NMIPRoutingRule) -> i32;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_table(self_: *const NMIPRoutingRule) -> u32;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_to(self_: *const NMIPRoutingRule) -> *const c_char;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_to_len(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_get_tos(self_: *const NMIPRoutingRule) -> u8;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_is_sealed(self_: *const NMIPRoutingRule) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_new_clone(rule: *const NMIPRoutingRule) -> *mut NMIPRoutingRule;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_ref(self_: *mut NMIPRoutingRule) -> *mut NMIPRoutingRule;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_seal(self_: *mut NMIPRoutingRule);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_action(self_: *mut NMIPRoutingRule, action: u8);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_destination_port(self_: *mut NMIPRoutingRule, start: u16, end: u16);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_fwmark(self_: *mut NMIPRoutingRule, fwmark: u32, fwmask: u32);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_iifname(self_: *mut NMIPRoutingRule, iifname: *const c_char);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_invert(self_: *mut NMIPRoutingRule, invert: gboolean);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_ipproto(self_: *mut NMIPRoutingRule, ipproto: u8);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_oifname(self_: *mut NMIPRoutingRule, oifname: *const c_char);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_priority(self_: *mut NMIPRoutingRule, priority: i64);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_source_port(self_: *mut NMIPRoutingRule, start: u16, end: u16);
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_suppress_prefixlength(self_: *mut NMIPRoutingRule, suppress_prefixlength: i32);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_table(self_: *mut NMIPRoutingRule, table: u32);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_set_tos(self_: *mut NMIPRoutingRule, tos: u8);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_to_string(self_: *const NMIPRoutingRule, to_string_flags: NMIPRoutingRuleAsStringFlags, extra_args: *mut glib::GHashTable, error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_unref(self_: *mut NMIPRoutingRule);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_validate(self_: *const NMIPRoutingRule, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_ip_routing_rule_from_string(str: *const c_char, to_string_flags: NMIPRoutingRuleAsStringFlags, extra_args: *mut glib::GHashTable, error: *mut *mut glib::GError) -> *mut NMIPRoutingRule;

    //=========================================================================
    // NMLldpNeighbor
    //=========================================================================
    pub fn nm_lldp_neighbor_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_new() -> *mut NMLldpNeighbor;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_get_attr_type(neighbor: *mut NMLldpNeighbor, name: *const c_char) -> *const glib::GVariantType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_get_attr_uint_value(neighbor: *mut NMLldpNeighbor, name: *const c_char, out_value: *mut c_uint) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_lldp_neighbor_get_attr_value(neighbor: *mut NMLldpNeighbor, name: *const c_char) -> *mut glib::GVariant;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_ref(neighbor: *mut NMLldpNeighbor);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_unref(neighbor: *mut NMLldpNeighbor);

    //=========================================================================
    // NMSriovVF
    //=========================================================================
    pub fn nm_sriov_vf_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_new(index: c_uint) -> *mut NMSriovVF;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_add_vlan(vf: *mut NMSriovVF, vlan_id: c_uint) -> gboolean;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_dup(vf: *const NMSriovVF) -> *mut NMSriovVF;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_equal(vf: *const NMSriovVF, other: *const NMSriovVF) -> gboolean;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_get_attribute(vf: *const NMSriovVF, name: *const c_char) -> *mut glib::GVariant;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_get_attribute_names(vf: *const NMSriovVF) -> *mut *const c_char;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_get_index(vf: *const NMSriovVF) -> c_uint;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_get_vlan_ids(vf: *const NMSriovVF, length: *mut c_uint) -> *const c_uint;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_get_vlan_protocol(vf: *const NMSriovVF, vlan_id: c_uint) -> NMSriovVFVlanProtocol;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_get_vlan_qos(vf: *const NMSriovVF, vlan_id: c_uint) -> u32;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_ref(vf: *mut NMSriovVF);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_remove_vlan(vf: *mut NMSriovVF, vlan_id: c_uint) -> gboolean;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_set_attribute(vf: *mut NMSriovVF, name: *const c_char, value: *mut glib::GVariant);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_set_vlan_protocol(vf: *mut NMSriovVF, vlan_id: c_uint, protocol: NMSriovVFVlanProtocol);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_set_vlan_qos(vf: *mut NMSriovVF, vlan_id: c_uint, qos: u32);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_unref(vf: *mut NMSriovVF);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_sriov_vf_attribute_validate(name: *const c_char, value: *mut glib::GVariant, known: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMTCQdisc
    //=========================================================================
    pub fn nm_tc_qdisc_get_type() -> GType;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_qdisc_new(kind: *const c_char, parent: u32, error: *mut *mut glib::GError) -> *mut NMTCQdisc;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_qdisc_dup(qdisc: *mut NMTCQdisc) -> *mut NMTCQdisc;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_qdisc_equal(qdisc: *mut NMTCQdisc, other: *mut NMTCQdisc) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_tc_qdisc_get_attribute(qdisc: *mut NMTCQdisc, name: *const c_char) -> *mut glib::GVariant;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_tc_qdisc_get_attribute_names(qdisc: *mut NMTCQdisc) -> *mut *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_qdisc_get_handle(qdisc: *mut NMTCQdisc) -> u32;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_qdisc_get_kind(qdisc: *mut NMTCQdisc) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_qdisc_get_parent(qdisc: *mut NMTCQdisc) -> u32;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_qdisc_ref(qdisc: *mut NMTCQdisc);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_tc_qdisc_set_attribute(qdisc: *mut NMTCQdisc, name: *const c_char, value: *mut glib::GVariant);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_qdisc_set_handle(qdisc: *mut NMTCQdisc, handle: u32);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_qdisc_unref(qdisc: *mut NMTCQdisc);

    //=========================================================================
    // NMTCTfilter
    //=========================================================================
    pub fn nm_tc_tfilter_get_type() -> GType;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_tfilter_new(kind: *const c_char, parent: u32, error: *mut *mut glib::GError) -> *mut NMTCTfilter;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_tfilter_dup(tfilter: *mut NMTCTfilter) -> *mut NMTCTfilter;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_tfilter_equal(tfilter: *mut NMTCTfilter, other: *mut NMTCTfilter) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_tfilter_get_handle(tfilter: *mut NMTCTfilter) -> u32;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_tfilter_get_kind(tfilter: *mut NMTCTfilter) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_tfilter_get_parent(tfilter: *mut NMTCTfilter) -> u32;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_tfilter_ref(tfilter: *mut NMTCTfilter);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_tfilter_set_handle(tfilter: *mut NMTCTfilter, handle: u32);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_tc_tfilter_unref(tfilter: *mut NMTCTfilter);

    //=========================================================================
    // NMTeamLinkWatcher
    //=========================================================================
    pub fn nm_team_link_watcher_get_type() -> GType;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_new_arp_ping(init_wait: c_int, interval: c_int, missed_max: c_int, target_host: *const c_char, source_host: *const c_char, flags: NMTeamLinkWatcherArpPingFlags, error: *mut *mut glib::GError) -> *mut NMTeamLinkWatcher;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_team_link_watcher_new_arp_ping2(init_wait: c_int, interval: c_int, missed_max: c_int, vlanid: c_int, target_host: *const c_char, source_host: *const c_char, flags: NMTeamLinkWatcherArpPingFlags, error: *mut *mut glib::GError) -> *mut NMTeamLinkWatcher;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_new_ethtool(delay_up: c_int, delay_down: c_int, error: *mut *mut glib::GError) -> *mut NMTeamLinkWatcher;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_new_nsna_ping(init_wait: c_int, interval: c_int, missed_max: c_int, target_host: *const c_char, error: *mut *mut glib::GError) -> *mut NMTeamLinkWatcher;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_dup(watcher: *const NMTeamLinkWatcher) -> *mut NMTeamLinkWatcher;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_equal(watcher: *const NMTeamLinkWatcher, other: *const NMTeamLinkWatcher) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_get_delay_down(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_get_delay_up(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_get_flags(watcher: *const NMTeamLinkWatcher) -> NMTeamLinkWatcherArpPingFlags;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_get_init_wait(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_get_interval(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_get_missed_max(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_get_name(watcher: *const NMTeamLinkWatcher) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_get_source_host(watcher: *const NMTeamLinkWatcher) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_get_target_host(watcher: *const NMTeamLinkWatcher) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_team_link_watcher_get_vlanid(watcher: *const NMTeamLinkWatcher) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_ref(watcher: *mut NMTeamLinkWatcher);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_team_link_watcher_unref(watcher: *mut NMTeamLinkWatcher);

    //=========================================================================
    // NMWireGuardPeer
    //=========================================================================
    pub fn nm_wireguard_peer_get_type() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_new() -> *mut NMWireGuardPeer;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_append_allowed_ip(self_: *mut NMWireGuardPeer, allowed_ip: *const c_char, accept_invalid: gboolean) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_clear_allowed_ips(self_: *mut NMWireGuardPeer);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_cmp(a: *const NMWireGuardPeer, b: *const NMWireGuardPeer, compare_flags: NMSettingCompareFlags) -> c_int;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_get_allowed_ips_len(self_: *const NMWireGuardPeer) -> c_uint;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_get_endpoint(self_: *const NMWireGuardPeer) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_get_persistent_keepalive(self_: *const NMWireGuardPeer) -> u16;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_get_preshared_key(self_: *const NMWireGuardPeer) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_get_preshared_key_flags(self_: *const NMWireGuardPeer) -> NMSettingSecretFlags;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_get_public_key(self_: *const NMWireGuardPeer) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_is_sealed(self_: *const NMWireGuardPeer) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_is_valid(self_: *const NMWireGuardPeer, check_non_secrets: gboolean, check_secrets: gboolean, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_new_clone(self_: *const NMWireGuardPeer, with_secrets: gboolean) -> *mut NMWireGuardPeer;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_ref(self_: *mut NMWireGuardPeer) -> *mut NMWireGuardPeer;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_remove_allowed_ip(self_: *mut NMWireGuardPeer, idx: c_uint) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_seal(self_: *mut NMWireGuardPeer);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_set_endpoint(self_: *mut NMWireGuardPeer, endpoint: *const c_char, allow_invalid: gboolean) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_set_persistent_keepalive(self_: *mut NMWireGuardPeer, persistent_keepalive: u16);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_set_preshared_key(self_: *mut NMWireGuardPeer, preshared_key: *const c_char, accept_invalid: gboolean) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_set_preshared_key_flags(self_: *mut NMWireGuardPeer, preshared_key_flags: NMSettingSecretFlags);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_set_public_key(self_: *mut NMWireGuardPeer, public_key: *const c_char, accept_invalid: gboolean) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wireguard_peer_unref(self_: *mut NMWireGuardPeer);

    //=========================================================================
    // NMAccessPoint
    //=========================================================================
    pub fn nm_access_point_get_type() -> GType;
    pub fn nm_access_point_connection_valid(ap: *mut NMAccessPoint, connection: *mut NMConnection) -> gboolean;
    pub fn nm_access_point_filter_connections(ap: *mut NMAccessPoint, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    pub fn nm_access_point_get_bssid(ap: *mut NMAccessPoint) -> *const c_char;
    pub fn nm_access_point_get_flags(ap: *mut NMAccessPoint) -> NM80211ApFlags;
    pub fn nm_access_point_get_frequency(ap: *mut NMAccessPoint) -> u32;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_access_point_get_last_seen(ap: *mut NMAccessPoint) -> c_int;
    pub fn nm_access_point_get_max_bitrate(ap: *mut NMAccessPoint) -> u32;
    pub fn nm_access_point_get_mode(ap: *mut NMAccessPoint) -> NM80211Mode;
    pub fn nm_access_point_get_rsn_flags(ap: *mut NMAccessPoint) -> NM80211ApSecurityFlags;
    pub fn nm_access_point_get_ssid(ap: *mut NMAccessPoint) -> *mut glib::GBytes;
    pub fn nm_access_point_get_strength(ap: *mut NMAccessPoint) -> u8;
    pub fn nm_access_point_get_wpa_flags(ap: *mut NMAccessPoint) -> NM80211ApSecurityFlags;

    //=========================================================================
    // NMActiveConnection
    //=========================================================================
    pub fn nm_active_connection_get_type() -> GType;
    pub fn nm_active_connection_get_connection(connection: *mut NMActiveConnection) -> *mut NMRemoteConnection;
    pub fn nm_active_connection_get_connection_type(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_default(connection: *mut NMActiveConnection) -> gboolean;
    pub fn nm_active_connection_get_default6(connection: *mut NMActiveConnection) -> gboolean;
    pub fn nm_active_connection_get_devices(connection: *mut NMActiveConnection) -> *const glib::GPtrArray;
    pub fn nm_active_connection_get_dhcp4_config(connection: *mut NMActiveConnection) -> *mut NMDhcpConfig;
    pub fn nm_active_connection_get_dhcp6_config(connection: *mut NMActiveConnection) -> *mut NMDhcpConfig;
    pub fn nm_active_connection_get_id(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_ip4_config(connection: *mut NMActiveConnection) -> *mut NMIPConfig;
    pub fn nm_active_connection_get_ip6_config(connection: *mut NMActiveConnection) -> *mut NMIPConfig;
    pub fn nm_active_connection_get_master(connection: *mut NMActiveConnection) -> *mut NMDevice;
    pub fn nm_active_connection_get_specific_object_path(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_state(connection: *mut NMActiveConnection) -> NMActiveConnectionState;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_active_connection_get_state_flags(connection: *mut NMActiveConnection) -> NMActivationStateFlags;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_active_connection_get_state_reason(connection: *mut NMActiveConnection) -> NMActiveConnectionStateReason;
    pub fn nm_active_connection_get_uuid(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_vpn(connection: *mut NMActiveConnection) -> gboolean;

    //=========================================================================
    // NMCheckpoint
    //=========================================================================
    pub fn nm_checkpoint_get_type() -> GType;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_checkpoint_get_created(checkpoint: *mut NMCheckpoint) -> i64;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_checkpoint_get_devices(checkpoint: *mut NMCheckpoint) -> *const glib::GPtrArray;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_checkpoint_get_rollback_timeout(checkpoint: *mut NMCheckpoint) -> u32;

    //=========================================================================
    // NMClient
    //=========================================================================
    pub fn nm_client_get_type() -> GType;
    pub fn nm_client_new(cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut NMClient;
    pub fn nm_client_new_finish(result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMClient;
    pub fn nm_client_new_async(cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_activate_connection_async(client: *mut NMClient, connection: *mut NMConnection, device: *mut NMDevice, specific_object: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_activate_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMActiveConnection;
    pub fn nm_client_add_and_activate_connection_async(client: *mut NMClient, partial: *mut NMConnection, device: *mut NMDevice, specific_object: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_add_and_activate_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMActiveConnection;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_client_add_connection2(client: *mut NMClient, settings: *mut glib::GVariant, flags: NMSettingsAddConnection2Flags, args: *mut glib::GVariant, ignore_out_result: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_client_add_connection2_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, out_result: *mut *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut NMRemoteConnection;
    pub fn nm_client_add_connection_async(client: *mut NMClient, connection: *mut NMConnection, save_to_disk: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_add_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMRemoteConnection;
    pub fn nm_client_check_connectivity(client: *mut NMClient, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> NMConnectivityState;
    pub fn nm_client_check_connectivity_async(client: *mut NMClient, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_check_connectivity_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> NMConnectivityState;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_client_checkpoint_adjust_rollback_timeout(client: *mut NMClient, checkpoint_path: *const c_char, add_timeout: u32, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_client_checkpoint_adjust_rollback_timeout_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_client_checkpoint_create_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMCheckpoint;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_client_checkpoint_destroy(client: *mut NMClient, checkpoint_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_client_checkpoint_destroy_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_client_checkpoint_rollback(client: *mut NMClient, checkpoint_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_client_checkpoint_rollback_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GHashTable;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_client_connectivity_check_get_available(client: *mut NMClient) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_client_connectivity_check_get_enabled(client: *mut NMClient) -> gboolean;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_client_connectivity_check_get_uri(client: *mut NMClient) -> *const c_char;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_client_connectivity_check_set_enabled(client: *mut NMClient, enabled: gboolean);
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_client_dbus_call(client: *mut NMClient, object_path: *const c_char, interface_name: *const c_char, method_name: *const c_char, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, timeout_msec: c_int, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_client_dbus_call_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_client_dbus_set_property(client: *mut NMClient, object_path: *const c_char, interface_name: *const c_char, property_name: *const c_char, value: *mut glib::GVariant, timeout_msec: c_int, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_client_dbus_set_property_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_deactivate_connection(client: *mut NMClient, active: *mut NMActiveConnection, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_deactivate_connection_async(client: *mut NMClient, active: *mut NMActiveConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_deactivate_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_get_activating_connection(client: *mut NMClient) -> *mut NMActiveConnection;
    pub fn nm_client_get_active_connections(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_client_get_all_devices(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_client_get_capabilities(client: *mut NMClient, length: *mut size_t) -> *const u32;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_client_get_checkpoints(client: *mut NMClient) -> *const glib::GPtrArray;
    pub fn nm_client_get_connection_by_id(client: *mut NMClient, id: *const c_char) -> *mut NMRemoteConnection;
    pub fn nm_client_get_connection_by_path(client: *mut NMClient, path: *const c_char) -> *mut NMRemoteConnection;
    pub fn nm_client_get_connection_by_uuid(client: *mut NMClient, uuid: *const c_char) -> *mut NMRemoteConnection;
    pub fn nm_client_get_connections(client: *mut NMClient) -> *const glib::GPtrArray;
    pub fn nm_client_get_connectivity(client: *mut NMClient) -> NMConnectivityState;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_client_get_context_busy_watcher(self_: *mut NMClient) -> *mut gobject::GObject;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_client_get_dbus_name_owner(client: *mut NMClient) -> *const c_char;
    pub fn nm_client_get_device_by_iface(client: *mut NMClient, iface: *const c_char) -> *mut NMDevice;
    pub fn nm_client_get_device_by_path(client: *mut NMClient, object_path: *const c_char) -> *mut NMDevice;
    pub fn nm_client_get_devices(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_client_get_dns_configuration(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_client_get_dns_mode(client: *mut NMClient) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_client_get_dns_rc_manager(client: *mut NMClient) -> *const c_char;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_client_get_instance_flags(self_: *mut NMClient) -> NMClientInstanceFlags;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_client_get_main_context(self_: *mut NMClient) -> *mut glib::GMainContext;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_client_get_metered(client: *mut NMClient) -> NMMetered;
    pub fn nm_client_get_nm_running(client: *mut NMClient) -> gboolean;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_client_get_object_by_path(client: *mut NMClient, dbus_path: *const c_char) -> *mut NMObject;
    pub fn nm_client_get_permission_result(client: *mut NMClient, permission: NMClientPermission) -> NMClientPermissionResult;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_client_get_permissions_state(self_: *mut NMClient) -> NMTernary;
    pub fn nm_client_get_primary_connection(client: *mut NMClient) -> *mut NMActiveConnection;
    pub fn nm_client_get_startup(client: *mut NMClient) -> gboolean;
    pub fn nm_client_get_state(client: *mut NMClient) -> NMState;
    pub fn nm_client_get_version(client: *mut NMClient) -> *const c_char;
    pub fn nm_client_networking_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_networking_set_enabled(client: *mut NMClient, enabled: gboolean, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_client_reload(client: *mut NMClient, flags: NMManagerReloadFlags, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_reload_connections(client: *mut NMClient, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_reload_connections_async(client: *mut NMClient, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_reload_connections_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_client_reload_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_save_hostname(client: *mut NMClient, hostname: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_save_hostname_async(client: *mut NMClient, hostname: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_save_hostname_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_set_logging(client: *mut NMClient, level: *const c_char, domains: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_wimax_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wimax_hardware_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wimax_set_enabled(client: *mut NMClient, enabled: gboolean);
    pub fn nm_client_wireless_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wireless_hardware_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wireless_set_enabled(client: *mut NMClient, enabled: gboolean);
    pub fn nm_client_wwan_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wwan_hardware_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wwan_set_enabled(client: *mut NMClient, enabled: gboolean);

    //=========================================================================
    // NMDevice
    //=========================================================================
    pub fn nm_device_get_type() -> GType;
    pub fn nm_device_disambiguate_names(devices: *mut *mut NMDevice, num_devices: c_int) -> *mut *mut c_char;
    pub fn nm_device_connection_compatible(device: *mut NMDevice, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_connection_valid(device: *mut NMDevice, connection: *mut NMConnection) -> gboolean;
    pub fn nm_device_delete(device: *mut NMDevice, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_delete_async(device: *mut NMDevice, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_device_delete_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_disconnect(device: *mut NMDevice, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_disconnect_async(device: *mut NMDevice, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_device_disconnect_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_filter_connections(device: *mut NMDevice, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    pub fn nm_device_get_active_connection(device: *mut NMDevice) -> *mut NMActiveConnection;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_applied_connection(device: *mut NMDevice, flags: u32, version_id: *mut u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut NMConnection;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_applied_connection_async(device: *mut NMDevice, flags: u32, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_applied_connection_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, version_id: *mut u64, error: *mut *mut glib::GError) -> *mut NMConnection;
    pub fn nm_device_get_autoconnect(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_get_available_connections(device: *mut NMDevice) -> *const glib::GPtrArray;
    pub fn nm_device_get_capabilities(device: *mut NMDevice) -> NMDeviceCapabilities;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_device_get_connectivity(device: *mut NMDevice, addr_family: c_int) -> NMConnectivityState;
    pub fn nm_device_get_description(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_device_type(device: *mut NMDevice) -> NMDeviceType;
    pub fn nm_device_get_dhcp4_config(device: *mut NMDevice) -> *mut NMDhcpConfig;
    pub fn nm_device_get_dhcp6_config(device: *mut NMDevice) -> *mut NMDhcpConfig;
    pub fn nm_device_get_driver(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_driver_version(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_firmware_missing(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_get_firmware_version(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_hw_address(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_iface(device: *mut NMDevice) -> *const c_char;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_device_get_interface_flags(device: *mut NMDevice) -> NMDeviceInterfaceFlags;
    pub fn nm_device_get_ip4_config(device: *mut NMDevice) -> *mut NMIPConfig;
    pub fn nm_device_get_ip6_config(device: *mut NMDevice) -> *mut NMIPConfig;
    pub fn nm_device_get_ip_iface(device: *mut NMDevice) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_lldp_neighbors(device: *mut NMDevice) -> *mut glib::GPtrArray;
    pub fn nm_device_get_managed(device: *mut NMDevice) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_metered(device: *mut NMDevice) -> NMMetered;
    pub fn nm_device_get_mtu(device: *mut NMDevice) -> u32;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_nm_plugin_missing(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_get_physical_port_id(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_product(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_setting_type(device: *mut NMDevice) -> GType;
    pub fn nm_device_get_state(device: *mut NMDevice) -> NMDeviceState;
    pub fn nm_device_get_state_reason(device: *mut NMDevice) -> NMDeviceStateReason;
    pub fn nm_device_get_type_description(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_udi(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_vendor(device: *mut NMDevice) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_is_real(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_is_software(device: *mut NMDevice) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_reapply(device: *mut NMDevice, connection: *mut NMConnection, version_id: u64, flags: u32, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_reapply_async(device: *mut NMDevice, connection: *mut NMConnection, version_id: u64, flags: u32, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_reapply_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_set_autoconnect(device: *mut NMDevice, autoconnect: gboolean);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_set_managed(device: *mut NMDevice, managed: gboolean);

    //=========================================================================
    // NMDevice6Lowpan
    //=========================================================================
    pub fn nm_device_6lowpan_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_device_6lowpan_get_hw_address(device: *mut NMDevice6Lowpan) -> *const c_char;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_device_6lowpan_get_parent(device: *mut NMDevice6Lowpan) -> *mut NMDevice;

    //=========================================================================
    // NMDeviceAdsl
    //=========================================================================
    pub fn nm_device_adsl_get_type() -> GType;
    pub fn nm_device_adsl_get_carrier(device: *mut NMDeviceAdsl) -> gboolean;

    //=========================================================================
    // NMDeviceBond
    //=========================================================================
    pub fn nm_device_bond_get_type() -> GType;
    pub fn nm_device_bond_get_carrier(device: *mut NMDeviceBond) -> gboolean;
    pub fn nm_device_bond_get_hw_address(device: *mut NMDeviceBond) -> *const c_char;
    pub fn nm_device_bond_get_slaves(device: *mut NMDeviceBond) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceBridge
    //=========================================================================
    pub fn nm_device_bridge_get_type() -> GType;
    pub fn nm_device_bridge_get_carrier(device: *mut NMDeviceBridge) -> gboolean;
    pub fn nm_device_bridge_get_hw_address(device: *mut NMDeviceBridge) -> *const c_char;
    pub fn nm_device_bridge_get_slaves(device: *mut NMDeviceBridge) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceBt
    //=========================================================================
    pub fn nm_device_bt_get_type() -> GType;
    pub fn nm_device_bt_get_capabilities(device: *mut NMDeviceBt) -> NMBluetoothCapabilities;
    pub fn nm_device_bt_get_hw_address(device: *mut NMDeviceBt) -> *const c_char;
    pub fn nm_device_bt_get_name(device: *mut NMDeviceBt) -> *const c_char;

    //=========================================================================
    // NMDeviceDummy
    //=========================================================================
    pub fn nm_device_dummy_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_device_dummy_get_hw_address(device: *mut NMDeviceDummy) -> *const c_char;

    //=========================================================================
    // NMDeviceEthernet
    //=========================================================================
    pub fn nm_device_ethernet_get_type() -> GType;
    pub fn nm_device_ethernet_get_carrier(device: *mut NMDeviceEthernet) -> gboolean;
    pub fn nm_device_ethernet_get_hw_address(device: *mut NMDeviceEthernet) -> *const c_char;
    pub fn nm_device_ethernet_get_permanent_hw_address(device: *mut NMDeviceEthernet) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ethernet_get_s390_subchannels(device: *mut NMDeviceEthernet) -> *const *const c_char;
    pub fn nm_device_ethernet_get_speed(device: *mut NMDeviceEthernet) -> u32;

    //=========================================================================
    // NMDeviceGeneric
    //=========================================================================
    pub fn nm_device_generic_get_type() -> GType;
    pub fn nm_device_generic_get_hw_address(device: *mut NMDeviceGeneric) -> *const c_char;

    //=========================================================================
    // NMDeviceIPTunnel
    //=========================================================================
    pub fn nm_device_ip_tunnel_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_encapsulation_limit(device: *mut NMDeviceIPTunnel) -> u8;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_flags(device: *mut NMDeviceIPTunnel) -> NMIPTunnelFlags;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_flow_label(device: *mut NMDeviceIPTunnel) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_input_key(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_local(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_mode(device: *mut NMDeviceIPTunnel) -> NMIPTunnelMode;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_output_key(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_parent(device: *mut NMDeviceIPTunnel) -> *mut NMDevice;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_path_mtu_discovery(device: *mut NMDeviceIPTunnel) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_remote(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_tos(device: *mut NMDeviceIPTunnel) -> u8;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_ttl(device: *mut NMDeviceIPTunnel) -> u8;

    //=========================================================================
    // NMDeviceInfiniband
    //=========================================================================
    pub fn nm_device_infiniband_get_type() -> GType;
    pub fn nm_device_infiniband_get_carrier(device: *mut NMDeviceInfiniband) -> gboolean;
    pub fn nm_device_infiniband_get_hw_address(device: *mut NMDeviceInfiniband) -> *const c_char;

    //=========================================================================
    // NMDeviceMacsec
    //=========================================================================
    pub fn nm_device_macsec_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_cipher_suite(device: *mut NMDeviceMacsec) -> u64;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_encoding_sa(device: *mut NMDeviceMacsec) -> u8;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_encrypt(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_es(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_hw_address(device: *mut NMDeviceMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_icv_length(device: *mut NMDeviceMacsec) -> u8;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_include_sci(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_parent(device: *mut NMDeviceMacsec) -> *mut NMDevice;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_protect(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_replay_protect(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_scb(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_sci(device: *mut NMDeviceMacsec) -> u64;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_validation(device: *mut NMDeviceMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_window(device: *mut NMDeviceMacsec) -> c_uint;

    //=========================================================================
    // NMDeviceMacvlan
    //=========================================================================
    pub fn nm_device_macvlan_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_hw_address(device: *mut NMDeviceMacvlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_mode(device: *mut NMDeviceMacvlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_no_promisc(device: *mut NMDeviceMacvlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_parent(device: *mut NMDeviceMacvlan) -> *mut NMDevice;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_tap(device: *mut NMDeviceMacvlan) -> gboolean;

    //=========================================================================
    // NMDeviceModem
    //=========================================================================
    pub fn nm_device_modem_get_type() -> GType;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_device_modem_get_apn(self_: *mut NMDeviceModem) -> *const c_char;
    pub fn nm_device_modem_get_current_capabilities(self_: *mut NMDeviceModem) -> NMDeviceModemCapabilities;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_device_modem_get_device_id(self_: *mut NMDeviceModem) -> *const c_char;
    pub fn nm_device_modem_get_modem_capabilities(self_: *mut NMDeviceModem) -> NMDeviceModemCapabilities;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_device_modem_get_operator_code(self_: *mut NMDeviceModem) -> *const c_char;

    //=========================================================================
    // NMDeviceOlpcMesh
    //=========================================================================
    pub fn nm_device_olpc_mesh_get_type() -> GType;
    pub fn nm_device_olpc_mesh_get_active_channel(device: *mut NMDeviceOlpcMesh) -> u32;
    pub fn nm_device_olpc_mesh_get_companion(device: *mut NMDeviceOlpcMesh) -> *mut NMDeviceWifi;
    pub fn nm_device_olpc_mesh_get_hw_address(device: *mut NMDeviceOlpcMesh) -> *const c_char;

    //=========================================================================
    // NMDeviceOvsBridge
    //=========================================================================
    pub fn nm_device_ovs_bridge_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_device_ovs_bridge_get_slaves(device: *mut NMDeviceOvsBridge) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceOvsInterface
    //=========================================================================
    pub fn nm_device_ovs_interface_get_type() -> GType;

    //=========================================================================
    // NMDeviceOvsPort
    //=========================================================================
    pub fn nm_device_ovs_port_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_device_ovs_port_get_slaves(device: *mut NMDeviceOvsPort) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDevicePpp
    //=========================================================================
    pub fn nm_device_ppp_get_type() -> GType;

    //=========================================================================
    // NMDeviceTeam
    //=========================================================================
    pub fn nm_device_team_get_type() -> GType;
    pub fn nm_device_team_get_carrier(device: *mut NMDeviceTeam) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_device_team_get_config(device: *mut NMDeviceTeam) -> *const c_char;
    pub fn nm_device_team_get_hw_address(device: *mut NMDeviceTeam) -> *const c_char;
    pub fn nm_device_team_get_slaves(device: *mut NMDeviceTeam) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceTun
    //=========================================================================
    pub fn nm_device_tun_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_group(device: *mut NMDeviceTun) -> i64;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_hw_address(device: *mut NMDeviceTun) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_mode(device: *mut NMDeviceTun) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_multi_queue(device: *mut NMDeviceTun) -> gboolean;
    pub fn nm_device_tun_get_no_pi(device: *mut NMDeviceTun) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_owner(device: *mut NMDeviceTun) -> i64;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_vnet_hdr(device: *mut NMDeviceTun) -> gboolean;

    //=========================================================================
    // NMDeviceVlan
    //=========================================================================
    pub fn nm_device_vlan_get_type() -> GType;
    pub fn nm_device_vlan_get_carrier(device: *mut NMDeviceVlan) -> gboolean;
    pub fn nm_device_vlan_get_hw_address(device: *mut NMDeviceVlan) -> *const c_char;
    pub fn nm_device_vlan_get_parent(device: *mut NMDeviceVlan) -> *mut NMDevice;
    pub fn nm_device_vlan_get_vlan_id(device: *mut NMDeviceVlan) -> c_uint;

    //=========================================================================
    // NMDeviceVrf
    //=========================================================================
    pub fn nm_device_vrf_get_type() -> GType;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_device_vrf_get_table(device: *mut NMDeviceVrf) -> u32;

    //=========================================================================
    // NMDeviceVxlan
    //=========================================================================
    pub fn nm_device_vxlan_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_ageing(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_carrier(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_dst_port(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_group(device: *mut NMDeviceVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_hw_address(device: *mut NMDeviceVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_id(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_l2miss(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_l3miss(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_learning(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_limit(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_local(device: *mut NMDeviceVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_parent(device: *mut NMDeviceVxlan) -> *mut NMDevice;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_proxy(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_rsc(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_src_port_max(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_src_port_min(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_tos(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_ttl(device: *mut NMDeviceVxlan) -> c_uint;

    //=========================================================================
    // NMDeviceWifi
    //=========================================================================
    pub fn nm_device_wifi_get_type() -> GType;
    pub fn nm_device_wifi_get_access_point_by_path(device: *mut NMDeviceWifi, path: *const c_char) -> *mut NMAccessPoint;
    pub fn nm_device_wifi_get_access_points(device: *mut NMDeviceWifi) -> *const glib::GPtrArray;
    pub fn nm_device_wifi_get_active_access_point(device: *mut NMDeviceWifi) -> *mut NMAccessPoint;
    pub fn nm_device_wifi_get_bitrate(device: *mut NMDeviceWifi) -> u32;
    pub fn nm_device_wifi_get_capabilities(device: *mut NMDeviceWifi) -> NMDeviceWifiCapabilities;
    pub fn nm_device_wifi_get_hw_address(device: *mut NMDeviceWifi) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_device_wifi_get_last_scan(device: *mut NMDeviceWifi) -> i64;
    pub fn nm_device_wifi_get_mode(device: *mut NMDeviceWifi) -> NM80211Mode;
    pub fn nm_device_wifi_get_permanent_hw_address(device: *mut NMDeviceWifi) -> *const c_char;
    pub fn nm_device_wifi_request_scan(device: *mut NMDeviceWifi, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_wifi_request_scan_async(device: *mut NMDeviceWifi, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_device_wifi_request_scan_finish(device: *mut NMDeviceWifi, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_wifi_request_scan_options(device: *mut NMDeviceWifi, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_wifi_request_scan_options_async(device: *mut NMDeviceWifi, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // NMDeviceWifiP2P
    //=========================================================================
    pub fn nm_device_wifi_p2p_get_type() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_device_wifi_p2p_get_hw_address(device: *mut NMDeviceWifiP2P) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_device_wifi_p2p_get_peer_by_path(device: *mut NMDeviceWifiP2P, path: *const c_char) -> *mut NMWifiP2PPeer;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_device_wifi_p2p_get_peers(device: *mut NMDeviceWifiP2P) -> *const glib::GPtrArray;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_device_wifi_p2p_start_find(device: *mut NMDeviceWifiP2P, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_device_wifi_p2p_start_find_finish(device: *mut NMDeviceWifiP2P, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_device_wifi_p2p_stop_find(device: *mut NMDeviceWifiP2P, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_device_wifi_p2p_stop_find_finish(device: *mut NMDeviceWifiP2P, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMDeviceWimax
    //=========================================================================
    pub fn nm_device_wimax_get_type() -> GType;
    pub fn nm_device_wimax_get_active_nsp(wimax: *mut NMDeviceWimax) -> *mut NMWimaxNsp;
    pub fn nm_device_wimax_get_bsid(self_: *mut NMDeviceWimax) -> *const c_char;
    pub fn nm_device_wimax_get_center_frequency(self_: *mut NMDeviceWimax) -> c_uint;
    pub fn nm_device_wimax_get_cinr(self_: *mut NMDeviceWimax) -> c_int;
    pub fn nm_device_wimax_get_hw_address(wimax: *mut NMDeviceWimax) -> *const c_char;
    pub fn nm_device_wimax_get_nsp_by_path(wimax: *mut NMDeviceWimax, path: *const c_char) -> *mut NMWimaxNsp;
    pub fn nm_device_wimax_get_nsps(wimax: *mut NMDeviceWimax) -> *const glib::GPtrArray;
    pub fn nm_device_wimax_get_rssi(self_: *mut NMDeviceWimax) -> c_int;
    pub fn nm_device_wimax_get_tx_power(self_: *mut NMDeviceWimax) -> c_int;

    //=========================================================================
    // NMDeviceWireGuard
    //=========================================================================
    pub fn nm_device_wireguard_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_device_wireguard_get_fwmark(device: *mut NMDeviceWireGuard) -> u32;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_device_wireguard_get_listen_port(device: *mut NMDeviceWireGuard) -> u16;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_device_wireguard_get_public_key(device: *mut NMDeviceWireGuard) -> *mut glib::GBytes;

    //=========================================================================
    // NMDhcpConfig
    //=========================================================================
    pub fn nm_dhcp_config_get_type() -> GType;
    pub fn nm_dhcp_config_get_family(config: *mut NMDhcpConfig) -> c_int;
    pub fn nm_dhcp_config_get_one_option(config: *mut NMDhcpConfig, option: *const c_char) -> *const c_char;
    pub fn nm_dhcp_config_get_options(config: *mut NMDhcpConfig) -> *mut glib::GHashTable;

    //=========================================================================
    // NMIPConfig
    //=========================================================================
    pub fn nm_ip_config_get_type() -> GType;
    pub fn nm_ip_config_get_addresses(config: *mut NMIPConfig) -> *mut glib::GPtrArray;
    pub fn nm_ip_config_get_domains(config: *mut NMIPConfig) -> *const *const c_char;
    pub fn nm_ip_config_get_family(config: *mut NMIPConfig) -> c_int;
    pub fn nm_ip_config_get_gateway(config: *mut NMIPConfig) -> *const c_char;
    pub fn nm_ip_config_get_nameservers(config: *mut NMIPConfig) -> *const *const c_char;
    pub fn nm_ip_config_get_routes(config: *mut NMIPConfig) -> *mut glib::GPtrArray;
    pub fn nm_ip_config_get_searches(config: *mut NMIPConfig) -> *const *const c_char;
    pub fn nm_ip_config_get_wins_servers(config: *mut NMIPConfig) -> *const *const c_char;

    //=========================================================================
    // NMObject
    //=========================================================================
    pub fn nm_object_get_type() -> GType;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_object_get_client(object: *mut NMObject) -> *mut NMClient;
    pub fn nm_object_get_path(object: *mut NMObject) -> *const c_char;

    //=========================================================================
    // NMRemoteConnection
    //=========================================================================
    pub fn nm_remote_connection_get_type() -> GType;
    pub fn nm_remote_connection_commit_changes(connection: *mut NMRemoteConnection, save_to_disk: gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_commit_changes_async(connection: *mut NMRemoteConnection, save_to_disk: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_commit_changes_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_delete(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_delete_async(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_delete_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_remote_connection_get_filename(connection: *mut NMRemoteConnection) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_remote_connection_get_flags(connection: *mut NMRemoteConnection) -> NMSettingsConnectionFlags;
    pub fn nm_remote_connection_get_secrets(connection: *mut NMRemoteConnection, setting_name: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn nm_remote_connection_get_secrets_async(connection: *mut NMRemoteConnection, setting_name: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_get_secrets_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn nm_remote_connection_get_unsaved(connection: *mut NMRemoteConnection) -> gboolean;
    pub fn nm_remote_connection_get_visible(connection: *mut NMRemoteConnection) -> gboolean;
    pub fn nm_remote_connection_save(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_save_async(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_save_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_remote_connection_update2(connection: *mut NMRemoteConnection, settings: *mut glib::GVariant, flags: NMSettingsUpdate2Flags, args: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_update2_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;

    //=========================================================================
    // NMSecretAgentOld
    //=========================================================================
    pub fn nm_secret_agent_old_get_type() -> GType;
    pub fn nm_secret_agent_old_delete_secrets(self_: *mut NMSecretAgentOld, connection: *mut NMConnection, callback: NMSecretAgentOldDeleteSecretsFunc, user_data: gpointer);
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_secret_agent_old_destroy(self_: *mut NMSecretAgentOld);
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_secret_agent_old_enable(self_: *mut NMSecretAgentOld, enable: gboolean);
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_secret_agent_old_get_context_busy_watcher(self_: *mut NMSecretAgentOld) -> *mut gobject::GObject;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_secret_agent_old_get_dbus_name_owner(self_: *mut NMSecretAgentOld) -> *const c_char;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_secret_agent_old_get_main_context(self_: *mut NMSecretAgentOld) -> *mut glib::GMainContext;
    pub fn nm_secret_agent_old_get_registered(self_: *mut NMSecretAgentOld) -> gboolean;
    pub fn nm_secret_agent_old_get_secrets(self_: *mut NMSecretAgentOld, connection: *mut NMConnection, setting_name: *const c_char, hints: *mut *const c_char, flags: NMSecretAgentGetSecretsFlags, callback: NMSecretAgentOldGetSecretsFunc, user_data: gpointer);
    pub fn nm_secret_agent_old_register(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_secret_agent_old_register_async(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_secret_agent_old_register_finish(self_: *mut NMSecretAgentOld, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_secret_agent_old_save_secrets(self_: *mut NMSecretAgentOld, connection: *mut NMConnection, callback: NMSecretAgentOldSaveSecretsFunc, user_data: gpointer);
    pub fn nm_secret_agent_old_unregister(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_secret_agent_old_unregister_async(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_secret_agent_old_unregister_finish(self_: *mut NMSecretAgentOld, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSetting
    //=========================================================================
    pub fn nm_setting_get_type() -> GType;
    pub fn nm_setting_lookup_type(name: *const c_char) -> GType;
    pub fn nm_setting_compare(a: *mut NMSetting, b: *mut NMSetting, flags: NMSettingCompareFlags) -> gboolean;
    pub fn nm_setting_diff(a: *mut NMSetting, b: *mut NMSetting, flags: NMSettingCompareFlags, invert_results: gboolean, results: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_setting_duplicate(setting: *mut NMSetting) -> *mut NMSetting;
    pub fn nm_setting_enumerate_values(setting: *mut NMSetting, func: NMSettingValueIterFn, user_data: gpointer);
    pub fn nm_setting_get_dbus_property_type(setting: *mut NMSetting, property_name: *const c_char) -> *const glib::GVariantType;
    pub fn nm_setting_get_name(setting: *mut NMSetting) -> *const c_char;
    pub fn nm_setting_set_secret_flags(setting: *mut NMSetting, secret_name: *const c_char, flags: NMSettingSecretFlags, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_to_string(setting: *mut NMSetting) -> *mut c_char;
    pub fn nm_setting_verify(setting: *mut NMSetting, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_verify_secrets(setting: *mut NMSetting, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSetting6Lowpan
    //=========================================================================
    pub fn nm_setting_6lowpan_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_6lowpan_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_6lowpan_get_parent(setting: *mut NMSetting6Lowpan) -> *const c_char;

    //=========================================================================
    // NMSetting8021x
    //=========================================================================
    pub fn nm_setting_802_1x_get_type() -> GType;
    pub fn nm_setting_802_1x_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_802_1x_check_cert_scheme(pdata: gconstpointer, length: size_t, error: *mut *mut glib::GError) -> NMSetting8021xCKScheme;
    pub fn nm_setting_802_1x_add_altsubject_match(setting: *mut NMSetting8021x, altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_add_eap_method(setting: *mut NMSetting8021x, eap: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_add_phase2_altsubject_match(setting: *mut NMSetting8021x, phase2_altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_clear_altsubject_matches(setting: *mut NMSetting8021x);
    pub fn nm_setting_802_1x_clear_eap_methods(setting: *mut NMSetting8021x);
    pub fn nm_setting_802_1x_clear_phase2_altsubject_matches(setting: *mut NMSetting8021x);
    pub fn nm_setting_802_1x_get_altsubject_match(setting: *mut NMSetting8021x, i: u32) -> *const c_char;
    pub fn nm_setting_802_1x_get_anonymous_identity(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_auth_timeout(setting: *mut NMSetting8021x) -> c_int;
    pub fn nm_setting_802_1x_get_ca_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_ca_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_ca_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_ca_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_ca_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_ca_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_ca_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_client_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_client_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_client_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_client_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_client_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_client_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_setting_802_1x_get_domain_match(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_802_1x_get_domain_suffix_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_eap_method(setting: *mut NMSetting8021x, i: u32) -> *const c_char;
    pub fn nm_setting_802_1x_get_identity(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_num_altsubject_matches(setting: *mut NMSetting8021x) -> u32;
    pub fn nm_setting_802_1x_get_num_eap_methods(setting: *mut NMSetting8021x) -> u32;
    pub fn nm_setting_802_1x_get_num_phase2_altsubject_matches(setting: *mut NMSetting8021x) -> u32;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_setting_802_1x_get_optional(setting: *mut NMSetting8021x) -> gboolean;
    pub fn nm_setting_802_1x_get_pac_file(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_password(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_password_raw(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    pub fn nm_setting_802_1x_get_password_raw_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase1_auth_flags(setting: *mut NMSetting8021x) -> NMSetting8021xAuthFlags;
    pub fn nm_setting_802_1x_get_phase1_fast_provisioning(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase1_peaplabel(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase1_peapver(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_altsubject_match(setting: *mut NMSetting8021x, i: u32) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_auth(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_autheap(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_ca_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_ca_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_ca_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_phase2_ca_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_ca_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_ca_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_ca_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_client_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_client_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_client_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_phase2_client_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_client_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_client_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_domain_match(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_domain_suffix_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_private_key_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    pub fn nm_setting_802_1x_get_phase2_private_key_format(setting: *mut NMSetting8021x) -> NMSetting8021xCKFormat;
    pub fn nm_setting_802_1x_get_phase2_private_key_password(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_private_key_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_phase2_private_key_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_private_key_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_private_key_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_subject_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_pin(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_pin_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_private_key_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    pub fn nm_setting_802_1x_get_private_key_format(setting: *mut NMSetting8021x) -> NMSetting8021xCKFormat;
    pub fn nm_setting_802_1x_get_private_key_password(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_private_key_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_private_key_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_private_key_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_private_key_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_subject_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_system_ca_certs(setting: *mut NMSetting8021x) -> gboolean;
    pub fn nm_setting_802_1x_remove_altsubject_match(setting: *mut NMSetting8021x, i: u32);
    pub fn nm_setting_802_1x_remove_altsubject_match_by_value(setting: *mut NMSetting8021x, altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_remove_eap_method(setting: *mut NMSetting8021x, i: u32);
    pub fn nm_setting_802_1x_remove_eap_method_by_value(setting: *mut NMSetting8021x, eap: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_remove_phase2_altsubject_match(setting: *mut NMSetting8021x, i: u32);
    pub fn nm_setting_802_1x_remove_phase2_altsubject_match_by_value(setting: *mut NMSetting8021x, phase2_altsubject_match: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingAdsl
    //=========================================================================
    pub fn nm_setting_adsl_get_type() -> GType;
    pub fn nm_setting_adsl_new() -> *mut NMSetting;
    pub fn nm_setting_adsl_get_encapsulation(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_password(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_password_flags(setting: *mut NMSettingAdsl) -> NMSettingSecretFlags;
    pub fn nm_setting_adsl_get_protocol(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_username(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_vci(setting: *mut NMSettingAdsl) -> u32;
    pub fn nm_setting_adsl_get_vpi(setting: *mut NMSettingAdsl) -> u32;

    //=========================================================================
    // NMSettingBluetooth
    //=========================================================================
    pub fn nm_setting_bluetooth_get_type() -> GType;
    pub fn nm_setting_bluetooth_new() -> *mut NMSetting;
    pub fn nm_setting_bluetooth_get_bdaddr(setting: *mut NMSettingBluetooth) -> *const c_char;
    pub fn nm_setting_bluetooth_get_connection_type(setting: *mut NMSettingBluetooth) -> *const c_char;

    //=========================================================================
    // NMSettingBond
    //=========================================================================
    pub fn nm_setting_bond_get_type() -> GType;
    pub fn nm_setting_bond_new() -> *mut NMSetting;
    pub fn nm_setting_bond_validate_option(name: *const c_char, value: *const c_char) -> gboolean;
    pub fn nm_setting_bond_add_option(setting: *mut NMSettingBond, name: *const c_char, value: *const c_char) -> gboolean;
    pub fn nm_setting_bond_get_num_options(setting: *mut NMSettingBond) -> u32;
    pub fn nm_setting_bond_get_option_by_name(setting: *mut NMSettingBond, name: *const c_char) -> *const c_char;
    pub fn nm_setting_bond_get_option_default(setting: *mut NMSettingBond, name: *const c_char) -> *const c_char;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_setting_bond_get_option_normalized(setting: *mut NMSettingBond, name: *const c_char) -> *const c_char;
    pub fn nm_setting_bond_get_valid_options(setting: *mut NMSettingBond) -> *mut *const c_char;
    pub fn nm_setting_bond_remove_option(setting: *mut NMSettingBond, name: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingBridge
    //=========================================================================
    pub fn nm_setting_bridge_get_type() -> GType;
    pub fn nm_setting_bridge_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_add_vlan(setting: *mut NMSettingBridge, vlan: *mut NMBridgeVlan);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_clear_vlans(setting: *mut NMSettingBridge);
    pub fn nm_setting_bridge_get_ageing_time(setting: *mut NMSettingBridge) -> u32;
    pub fn nm_setting_bridge_get_forward_delay(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_group_address(setting: *const NMSettingBridge) -> *const c_char;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_bridge_get_group_forward_mask(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_hello_time(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_mac_address(setting: *mut NMSettingBridge) -> *const c_char;
    pub fn nm_setting_bridge_get_max_age(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_multicast_querier(setting: *const NMSettingBridge) -> gboolean;
    pub fn nm_setting_bridge_get_multicast_query_use_ifaddr(setting: *const NMSettingBridge) -> gboolean;
    pub fn nm_setting_bridge_get_multicast_router(setting: *const NMSettingBridge) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_bridge_get_multicast_snooping(setting: *mut NMSettingBridge) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_get_num_vlans(setting: *mut NMSettingBridge) -> c_uint;
    pub fn nm_setting_bridge_get_priority(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_stp(setting: *mut NMSettingBridge) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_get_vlan(setting: *mut NMSettingBridge, idx: c_uint) -> *mut NMBridgeVlan;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_get_vlan_default_pvid(setting: *mut NMSettingBridge) -> u16;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_get_vlan_filtering(setting: *mut NMSettingBridge) -> gboolean;
    pub fn nm_setting_bridge_get_vlan_protocol(setting: *const NMSettingBridge) -> *const c_char;
    pub fn nm_setting_bridge_get_vlan_stats_enabled(setting: *const NMSettingBridge) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_remove_vlan(setting: *mut NMSettingBridge, idx: c_uint);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_remove_vlan_by_vid(setting: *mut NMSettingBridge, vid_start: u16, vid_end: u16) -> gboolean;

    //=========================================================================
    // NMSettingBridgePort
    //=========================================================================
    pub fn nm_setting_bridge_port_get_type() -> GType;
    pub fn nm_setting_bridge_port_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_port_add_vlan(setting: *mut NMSettingBridgePort, vlan: *mut NMBridgeVlan);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_port_clear_vlans(setting: *mut NMSettingBridgePort);
    pub fn nm_setting_bridge_port_get_hairpin_mode(setting: *mut NMSettingBridgePort) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_port_get_num_vlans(setting: *mut NMSettingBridgePort) -> c_uint;
    pub fn nm_setting_bridge_port_get_path_cost(setting: *mut NMSettingBridgePort) -> u16;
    pub fn nm_setting_bridge_port_get_priority(setting: *mut NMSettingBridgePort) -> u16;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_port_get_vlan(setting: *mut NMSettingBridgePort, idx: c_uint) -> *mut NMBridgeVlan;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_port_remove_vlan(setting: *mut NMSettingBridgePort, idx: c_uint);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_bridge_port_remove_vlan_by_vid(setting: *mut NMSettingBridgePort, vid_start: u16, vid_end: u16) -> gboolean;

    //=========================================================================
    // NMSettingCdma
    //=========================================================================
    pub fn nm_setting_cdma_get_type() -> GType;
    pub fn nm_setting_cdma_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_cdma_get_mtu(setting: *mut NMSettingCdma) -> u32;
    pub fn nm_setting_cdma_get_number(setting: *mut NMSettingCdma) -> *const c_char;
    pub fn nm_setting_cdma_get_password(setting: *mut NMSettingCdma) -> *const c_char;
    pub fn nm_setting_cdma_get_password_flags(setting: *mut NMSettingCdma) -> NMSettingSecretFlags;
    pub fn nm_setting_cdma_get_username(setting: *mut NMSettingCdma) -> *const c_char;

    //=========================================================================
    // NMSettingConnection
    //=========================================================================
    pub fn nm_setting_connection_get_type() -> GType;
    pub fn nm_setting_connection_new() -> *mut NMSetting;
    pub fn nm_setting_connection_add_permission(setting: *mut NMSettingConnection, ptype: *const c_char, pitem: *const c_char, detail: *const c_char) -> gboolean;
    pub fn nm_setting_connection_add_secondary(setting: *mut NMSettingConnection, sec_uuid: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_connection_get_auth_retries(setting: *mut NMSettingConnection) -> c_int;
    pub fn nm_setting_connection_get_autoconnect(setting: *mut NMSettingConnection) -> gboolean;
    pub fn nm_setting_connection_get_autoconnect_priority(setting: *mut NMSettingConnection) -> c_int;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_connection_get_autoconnect_retries(setting: *mut NMSettingConnection) -> c_int;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_connection_get_autoconnect_slaves(setting: *mut NMSettingConnection) -> NMSettingConnectionAutoconnectSlaves;
    pub fn nm_setting_connection_get_connection_type(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_gateway_ping_timeout(setting: *mut NMSettingConnection) -> u32;
    pub fn nm_setting_connection_get_id(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_interface_name(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_connection_get_lldp(setting: *mut NMSettingConnection) -> NMSettingConnectionLldp;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_connection_get_llmnr(setting: *mut NMSettingConnection) -> NMSettingConnectionLlmnr;
    pub fn nm_setting_connection_get_master(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_connection_get_mdns(setting: *mut NMSettingConnection) -> NMSettingConnectionMdns;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_connection_get_metered(setting: *mut NMSettingConnection) -> NMMetered;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_connection_get_multi_connect(setting: *mut NMSettingConnection) -> NMConnectionMultiConnect;
    pub fn nm_setting_connection_get_num_permissions(setting: *mut NMSettingConnection) -> u32;
    pub fn nm_setting_connection_get_num_secondaries(setting: *mut NMSettingConnection) -> u32;
    pub fn nm_setting_connection_get_read_only(setting: *mut NMSettingConnection) -> gboolean;
    pub fn nm_setting_connection_get_secondary(setting: *mut NMSettingConnection, idx: u32) -> *const c_char;
    pub fn nm_setting_connection_get_slave_type(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_connection_get_stable_id(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_timestamp(setting: *mut NMSettingConnection) -> u64;
    pub fn nm_setting_connection_get_uuid(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_setting_connection_get_wait_device_timeout(setting: *mut NMSettingConnection) -> i32;
    pub fn nm_setting_connection_get_zone(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_is_slave_type(setting: *mut NMSettingConnection, type_: *const c_char) -> gboolean;
    pub fn nm_setting_connection_permissions_user_allowed(setting: *mut NMSettingConnection, uname: *const c_char) -> gboolean;
    pub fn nm_setting_connection_remove_permission(setting: *mut NMSettingConnection, idx: u32);
    pub fn nm_setting_connection_remove_permission_by_value(setting: *mut NMSettingConnection, ptype: *const c_char, pitem: *const c_char, detail: *const c_char) -> gboolean;
    pub fn nm_setting_connection_remove_secondary(setting: *mut NMSettingConnection, idx: u32);
    pub fn nm_setting_connection_remove_secondary_by_value(setting: *mut NMSettingConnection, sec_uuid: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingDcb
    //=========================================================================
    pub fn nm_setting_dcb_get_type() -> GType;
    pub fn nm_setting_dcb_new() -> *mut NMSetting;
    pub fn nm_setting_dcb_get_app_fcoe_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_app_fcoe_mode(setting: *mut NMSettingDcb) -> *const c_char;
    pub fn nm_setting_dcb_get_app_fcoe_priority(setting: *mut NMSettingDcb) -> c_int;
    pub fn nm_setting_dcb_get_app_fip_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_app_fip_priority(setting: *mut NMSettingDcb) -> c_int;
    pub fn nm_setting_dcb_get_app_iscsi_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_app_iscsi_priority(setting: *mut NMSettingDcb) -> c_int;
    pub fn nm_setting_dcb_get_priority_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint) -> c_uint;
    pub fn nm_setting_dcb_get_priority_flow_control(setting: *mut NMSettingDcb, user_priority: c_uint) -> gboolean;
    pub fn nm_setting_dcb_get_priority_flow_control_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_priority_group_bandwidth(setting: *mut NMSettingDcb, group_id: c_uint) -> c_uint;
    pub fn nm_setting_dcb_get_priority_group_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_priority_group_id(setting: *mut NMSettingDcb, user_priority: c_uint) -> c_uint;
    pub fn nm_setting_dcb_get_priority_strict_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint) -> gboolean;
    pub fn nm_setting_dcb_get_priority_traffic_class(setting: *mut NMSettingDcb, user_priority: c_uint) -> c_uint;
    pub fn nm_setting_dcb_set_priority_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint, bandwidth_percent: c_uint);
    pub fn nm_setting_dcb_set_priority_flow_control(setting: *mut NMSettingDcb, user_priority: c_uint, enabled: gboolean);
    pub fn nm_setting_dcb_set_priority_group_bandwidth(setting: *mut NMSettingDcb, group_id: c_uint, bandwidth_percent: c_uint);
    pub fn nm_setting_dcb_set_priority_group_id(setting: *mut NMSettingDcb, user_priority: c_uint, group_id: c_uint);
    pub fn nm_setting_dcb_set_priority_strict_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint, strict: gboolean);
    pub fn nm_setting_dcb_set_priority_traffic_class(setting: *mut NMSettingDcb, user_priority: c_uint, traffic_class: c_uint);

    //=========================================================================
    // NMSettingDummy
    //=========================================================================
    pub fn nm_setting_dummy_get_type() -> GType;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_dummy_new() -> *mut NMSetting;

    //=========================================================================
    // NMSettingEthtool
    //=========================================================================
    pub fn nm_setting_ethtool_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_ethtool_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_ethtool_clear_features(setting: *mut NMSettingEthtool);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_ethtool_get_feature(setting: *mut NMSettingEthtool, optname: *const c_char) -> NMTernary;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_setting_ethtool_get_optnames(setting: *mut NMSettingEthtool, out_length: *mut c_uint) -> *mut *const c_char;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_ethtool_set_feature(setting: *mut NMSettingEthtool, optname: *const c_char, value: NMTernary);

    //=========================================================================
    // NMSettingGeneric
    //=========================================================================
    pub fn nm_setting_generic_get_type() -> GType;
    pub fn nm_setting_generic_new() -> *mut NMSetting;

    //=========================================================================
    // NMSettingGsm
    //=========================================================================
    pub fn nm_setting_gsm_get_type() -> GType;
    pub fn nm_setting_gsm_new() -> *mut NMSetting;
    pub fn nm_setting_gsm_get_apn(setting: *mut NMSettingGsm) -> *const c_char;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_setting_gsm_get_auto_config(setting: *mut NMSettingGsm) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_gsm_get_device_id(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_home_only(setting: *mut NMSettingGsm) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_gsm_get_mtu(setting: *mut NMSettingGsm) -> u32;
    pub fn nm_setting_gsm_get_network_id(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_number(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_password(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_password_flags(setting: *mut NMSettingGsm) -> NMSettingSecretFlags;
    pub fn nm_setting_gsm_get_pin(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_pin_flags(setting: *mut NMSettingGsm) -> NMSettingSecretFlags;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_gsm_get_sim_id(setting: *mut NMSettingGsm) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_gsm_get_sim_operator_id(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_username(setting: *mut NMSettingGsm) -> *const c_char;

    //=========================================================================
    // NMSettingIP4Config
    //=========================================================================
    pub fn nm_setting_ip4_config_get_type() -> GType;
    pub fn nm_setting_ip4_config_new() -> *mut NMSetting;
    pub fn nm_setting_ip4_config_get_dhcp_client_id(setting: *mut NMSettingIP4Config) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip4_config_get_dhcp_fqdn(setting: *mut NMSettingIP4Config) -> *const c_char;

    //=========================================================================
    // NMSettingIP6Config
    //=========================================================================
    pub fn nm_setting_ip6_config_get_type() -> GType;
    pub fn nm_setting_ip6_config_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip6_config_get_addr_gen_mode(setting: *mut NMSettingIP6Config) -> NMSettingIP6ConfigAddrGenMode;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_ip6_config_get_dhcp_duid(setting: *mut NMSettingIP6Config) -> *const c_char;
    pub fn nm_setting_ip6_config_get_ip6_privacy(setting: *mut NMSettingIP6Config) -> NMSettingIP6ConfigPrivacy;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_setting_ip6_config_get_ra_timeout(setting: *mut NMSettingIP6Config) -> i32;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_ip6_config_get_token(setting: *mut NMSettingIP6Config) -> *const c_char;

    //=========================================================================
    // NMSettingIPConfig
    //=========================================================================
    pub fn nm_setting_ip_config_get_type() -> GType;
    pub fn nm_setting_ip_config_add_address(setting: *mut NMSettingIPConfig, address: *mut NMIPAddress) -> gboolean;
    pub fn nm_setting_ip_config_add_dns(setting: *mut NMSettingIPConfig, dns: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_add_dns_option(setting: *mut NMSettingIPConfig, dns_option: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_add_dns_search(setting: *mut NMSettingIPConfig, dns_search: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_add_route(setting: *mut NMSettingIPConfig, route: *mut NMIPRoute) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_ip_config_add_routing_rule(setting: *mut NMSettingIPConfig, routing_rule: *mut NMIPRoutingRule);
    pub fn nm_setting_ip_config_clear_addresses(setting: *mut NMSettingIPConfig);
    pub fn nm_setting_ip_config_clear_dns(setting: *mut NMSettingIPConfig);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_clear_dns_options(setting: *mut NMSettingIPConfig, is_set: gboolean);
    pub fn nm_setting_ip_config_clear_dns_searches(setting: *mut NMSettingIPConfig);
    pub fn nm_setting_ip_config_clear_routes(setting: *mut NMSettingIPConfig);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_ip_config_clear_routing_rules(setting: *mut NMSettingIPConfig);
    pub fn nm_setting_ip_config_get_address(setting: *mut NMSettingIPConfig, idx: c_int) -> *mut NMIPAddress;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dad_timeout(setting: *mut NMSettingIPConfig) -> c_int;
    pub fn nm_setting_ip_config_get_dhcp_hostname(setting: *mut NMSettingIPConfig) -> *const c_char;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dhcp_hostname_flags(setting: *mut NMSettingIPConfig) -> NMDhcpHostnameFlags;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dhcp_iaid(setting: *mut NMSettingIPConfig) -> *const c_char;
    pub fn nm_setting_ip_config_get_dhcp_send_hostname(setting: *mut NMSettingIPConfig) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dhcp_timeout(setting: *mut NMSettingIPConfig) -> c_int;
    pub fn nm_setting_ip_config_get_dns(setting: *mut NMSettingIPConfig, idx: c_int) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dns_option(setting: *mut NMSettingIPConfig, idx: c_uint) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dns_priority(setting: *mut NMSettingIPConfig) -> c_int;
    pub fn nm_setting_ip_config_get_dns_search(setting: *mut NMSettingIPConfig, idx: c_int) -> *const c_char;
    pub fn nm_setting_ip_config_get_gateway(setting: *mut NMSettingIPConfig) -> *const c_char;
    pub fn nm_setting_ip_config_get_ignore_auto_dns(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_ignore_auto_routes(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_may_fail(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_method(setting: *mut NMSettingIPConfig) -> *const c_char;
    pub fn nm_setting_ip_config_get_never_default(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_num_addresses(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_num_dns(setting: *mut NMSettingIPConfig) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_get_num_dns_options(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_num_dns_searches(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_num_routes(setting: *mut NMSettingIPConfig) -> c_uint;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_ip_config_get_num_routing_rules(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_route(setting: *mut NMSettingIPConfig, idx: c_int) -> *mut NMIPRoute;
    pub fn nm_setting_ip_config_get_route_metric(setting: *mut NMSettingIPConfig) -> i64;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ip_config_get_route_table(setting: *mut NMSettingIPConfig) -> u32;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_ip_config_get_routing_rule(setting: *mut NMSettingIPConfig, idx: c_uint) -> *mut NMIPRoutingRule;
    pub fn nm_setting_ip_config_has_dns_options(setting: *mut NMSettingIPConfig) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_next_valid_dns_option(setting: *mut NMSettingIPConfig, idx: c_uint) -> c_int;
    pub fn nm_setting_ip_config_remove_address(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_address_by_value(setting: *mut NMSettingIPConfig, address: *mut NMIPAddress) -> gboolean;
    pub fn nm_setting_ip_config_remove_dns(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_dns_by_value(setting: *mut NMSettingIPConfig, dns: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_remove_dns_option(setting: *mut NMSettingIPConfig, idx: c_int);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_remove_dns_option_by_value(setting: *mut NMSettingIPConfig, dns_option: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_remove_dns_search(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_dns_search_by_value(setting: *mut NMSettingIPConfig, dns_search: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_remove_route(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_route_by_value(setting: *mut NMSettingIPConfig, route: *mut NMIPRoute) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    pub fn nm_setting_ip_config_remove_routing_rule(setting: *mut NMSettingIPConfig, idx: c_uint);

    //=========================================================================
    // NMSettingIPTunnel
    //=========================================================================
    pub fn nm_setting_ip_tunnel_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_encapsulation_limit(setting: *mut NMSettingIPTunnel) -> c_uint;
    pub fn nm_setting_ip_tunnel_get_flags(setting: *mut NMSettingIPTunnel) -> NMIPTunnelFlags;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_flow_label(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_input_key(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_local(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_mode(setting: *mut NMSettingIPTunnel) -> NMIPTunnelMode;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_mtu(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_output_key(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_parent(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_path_mtu_discovery(setting: *mut NMSettingIPTunnel) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_remote(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_tos(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_ttl(setting: *mut NMSettingIPTunnel) -> c_uint;

    //=========================================================================
    // NMSettingInfiniband
    //=========================================================================
    pub fn nm_setting_infiniband_get_type() -> GType;
    pub fn nm_setting_infiniband_new() -> *mut NMSetting;
    pub fn nm_setting_infiniband_get_mac_address(setting: *mut NMSettingInfiniband) -> *const c_char;
    pub fn nm_setting_infiniband_get_mtu(setting: *mut NMSettingInfiniband) -> u32;
    pub fn nm_setting_infiniband_get_p_key(setting: *mut NMSettingInfiniband) -> c_int;
    pub fn nm_setting_infiniband_get_parent(setting: *mut NMSettingInfiniband) -> *const c_char;
    pub fn nm_setting_infiniband_get_transport_mode(setting: *mut NMSettingInfiniband) -> *const c_char;
    pub fn nm_setting_infiniband_get_virtual_interface_name(setting: *mut NMSettingInfiniband) -> *const c_char;

    //=========================================================================
    // NMSettingMacsec
    //=========================================================================
    pub fn nm_setting_macsec_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_encrypt(setting: *mut NMSettingMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_mka_cak(setting: *mut NMSettingMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_mka_cak_flags(setting: *mut NMSettingMacsec) -> NMSettingSecretFlags;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_mka_ckn(setting: *mut NMSettingMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_mode(setting: *mut NMSettingMacsec) -> NMSettingMacsecMode;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_parent(setting: *mut NMSettingMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_port(setting: *mut NMSettingMacsec) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_macsec_get_send_sci(setting: *mut NMSettingMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_validation(setting: *mut NMSettingMacsec) -> NMSettingMacsecValidation;

    //=========================================================================
    // NMSettingMacvlan
    //=========================================================================
    pub fn nm_setting_macvlan_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_get_mode(setting: *mut NMSettingMacvlan) -> NMSettingMacvlanMode;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_get_parent(setting: *mut NMSettingMacvlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_get_promiscuous(setting: *mut NMSettingMacvlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_get_tap(setting: *mut NMSettingMacvlan) -> gboolean;

    //=========================================================================
    // NMSettingMatch
    //=========================================================================
    pub fn nm_setting_match_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_match_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_match_add_interface_name(setting: *mut NMSettingMatch, interface_name: *const c_char);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_match_clear_interface_names(setting: *mut NMSettingMatch);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_match_get_interface_name(setting: *mut NMSettingMatch, idx: c_int) -> *const c_char;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_match_get_num_interface_names(setting: *mut NMSettingMatch) -> c_uint;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_match_remove_interface_name(setting: *mut NMSettingMatch, idx: c_int);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_match_remove_interface_name_by_value(setting: *mut NMSettingMatch, interface_name: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingOlpcMesh
    //=========================================================================
    pub fn nm_setting_olpc_mesh_get_type() -> GType;
    pub fn nm_setting_olpc_mesh_new() -> *mut NMSetting;
    pub fn nm_setting_olpc_mesh_get_channel(setting: *mut NMSettingOlpcMesh) -> u32;
    pub fn nm_setting_olpc_mesh_get_dhcp_anycast_address(setting: *mut NMSettingOlpcMesh) -> *const c_char;
    pub fn nm_setting_olpc_mesh_get_ssid(setting: *mut NMSettingOlpcMesh) -> *mut glib::GBytes;

    //=========================================================================
    // NMSettingOvsBridge
    //=========================================================================
    pub fn nm_setting_ovs_bridge_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_bridge_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_setting_ovs_bridge_get_datapath_type(self_: *mut NMSettingOvsBridge) -> *const c_char;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_bridge_get_fail_mode(self_: *mut NMSettingOvsBridge) -> *const c_char;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_bridge_get_mcast_snooping_enable(self_: *mut NMSettingOvsBridge) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_bridge_get_rstp_enable(self_: *mut NMSettingOvsBridge) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_bridge_get_stp_enable(self_: *mut NMSettingOvsBridge) -> gboolean;

    //=========================================================================
    // NMSettingOvsDpdk
    //=========================================================================
    pub fn nm_setting_ovs_dpdk_get_type() -> GType;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_setting_ovs_dpdk_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_setting_ovs_dpdk_get_devargs(self_: *mut NMSettingOvsDpdk) -> *const c_char;

    //=========================================================================
    // NMSettingOvsInterface
    //=========================================================================
    pub fn nm_setting_ovs_interface_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_interface_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_interface_get_interface_type(self_: *mut NMSettingOvsInterface) -> *const c_char;

    //=========================================================================
    // NMSettingOvsPatch
    //=========================================================================
    pub fn nm_setting_ovs_patch_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_patch_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_patch_get_peer(self_: *mut NMSettingOvsPatch) -> *const c_char;

    //=========================================================================
    // NMSettingOvsPort
    //=========================================================================
    pub fn nm_setting_ovs_port_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_port_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_port_get_bond_downdelay(self_: *mut NMSettingOvsPort) -> c_uint;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_port_get_bond_mode(self_: *mut NMSettingOvsPort) -> *const c_char;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_port_get_bond_updelay(self_: *mut NMSettingOvsPort) -> c_uint;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_port_get_lacp(self_: *mut NMSettingOvsPort) -> *const c_char;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_port_get_tag(self_: *mut NMSettingOvsPort) -> c_uint;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_ovs_port_get_vlan_mode(self_: *mut NMSettingOvsPort) -> *const c_char;

    //=========================================================================
    // NMSettingPpp
    //=========================================================================
    pub fn nm_setting_ppp_get_type() -> GType;
    pub fn nm_setting_ppp_new() -> *mut NMSetting;
    pub fn nm_setting_ppp_get_baud(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_crtscts(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_lcp_echo_failure(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_lcp_echo_interval(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_mppe_stateful(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_mru(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_mtu(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_no_vj_comp(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_noauth(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_nobsdcomp(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_nodeflate(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_chap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_eap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_mschap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_mschapv2(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_pap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_require_mppe(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_require_mppe_128(setting: *mut NMSettingPpp) -> gboolean;

    //=========================================================================
    // NMSettingPppoe
    //=========================================================================
    pub fn nm_setting_pppoe_get_type() -> GType;
    pub fn nm_setting_pppoe_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_pppoe_get_parent(setting: *mut NMSettingPppoe) -> *const c_char;
    pub fn nm_setting_pppoe_get_password(setting: *mut NMSettingPppoe) -> *const c_char;
    pub fn nm_setting_pppoe_get_password_flags(setting: *mut NMSettingPppoe) -> NMSettingSecretFlags;
    pub fn nm_setting_pppoe_get_service(setting: *mut NMSettingPppoe) -> *const c_char;
    pub fn nm_setting_pppoe_get_username(setting: *mut NMSettingPppoe) -> *const c_char;

    //=========================================================================
    // NMSettingProxy
    //=========================================================================
    pub fn nm_setting_proxy_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_get_browser_only(setting: *mut NMSettingProxy) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_get_method(setting: *mut NMSettingProxy) -> NMSettingProxyMethod;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_get_pac_script(setting: *mut NMSettingProxy) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_get_pac_url(setting: *mut NMSettingProxy) -> *const c_char;

    //=========================================================================
    // NMSettingSerial
    //=========================================================================
    pub fn nm_setting_serial_get_type() -> GType;
    pub fn nm_setting_serial_new() -> *mut NMSetting;
    pub fn nm_setting_serial_get_baud(setting: *mut NMSettingSerial) -> c_uint;
    pub fn nm_setting_serial_get_bits(setting: *mut NMSettingSerial) -> c_uint;
    pub fn nm_setting_serial_get_parity(setting: *mut NMSettingSerial) -> NMSettingSerialParity;
    pub fn nm_setting_serial_get_send_delay(setting: *mut NMSettingSerial) -> u64;
    pub fn nm_setting_serial_get_stopbits(setting: *mut NMSettingSerial) -> c_uint;

    //=========================================================================
    // NMSettingSriov
    //=========================================================================
    pub fn nm_setting_sriov_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_sriov_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_sriov_add_vf(setting: *mut NMSettingSriov, vf: *mut NMSriovVF);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_sriov_clear_vfs(setting: *mut NMSettingSriov);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_sriov_get_autoprobe_drivers(setting: *mut NMSettingSriov) -> NMTernary;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_sriov_get_num_vfs(setting: *mut NMSettingSriov) -> c_uint;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_sriov_get_total_vfs(setting: *mut NMSettingSriov) -> c_uint;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_sriov_get_vf(setting: *mut NMSettingSriov, idx: c_uint) -> *mut NMSriovVF;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_sriov_remove_vf(setting: *mut NMSettingSriov, idx: c_uint);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_sriov_remove_vf_by_index(setting: *mut NMSettingSriov, index: c_uint) -> gboolean;

    //=========================================================================
    // NMSettingTCConfig
    //=========================================================================
    pub fn nm_setting_tc_config_get_type() -> GType;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_add_qdisc(setting: *mut NMSettingTCConfig, qdisc: *mut NMTCQdisc) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_add_tfilter(setting: *mut NMSettingTCConfig, tfilter: *mut NMTCTfilter) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_clear_qdiscs(setting: *mut NMSettingTCConfig);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_clear_tfilters(setting: *mut NMSettingTCConfig);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_get_num_qdiscs(setting: *mut NMSettingTCConfig) -> c_uint;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_get_num_tfilters(setting: *mut NMSettingTCConfig) -> c_uint;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_get_qdisc(setting: *mut NMSettingTCConfig, idx: c_uint) -> *mut NMTCQdisc;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_get_tfilter(setting: *mut NMSettingTCConfig, idx: c_uint) -> *mut NMTCTfilter;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_remove_qdisc(setting: *mut NMSettingTCConfig, idx: c_uint);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_remove_qdisc_by_value(setting: *mut NMSettingTCConfig, qdisc: *mut NMTCQdisc) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_remove_tfilter(setting: *mut NMSettingTCConfig, idx: c_uint);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_tc_config_remove_tfilter_by_value(setting: *mut NMSettingTCConfig, tfilter: *mut NMTCTfilter) -> gboolean;

    //=========================================================================
    // NMSettingTeam
    //=========================================================================
    pub fn nm_setting_team_get_type() -> GType;
    pub fn nm_setting_team_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_add_link_watcher(setting: *mut NMSettingTeam, link_watcher: *mut NMTeamLinkWatcher) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_add_runner_tx_hash(setting: *mut NMSettingTeam, txhash: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_clear_link_watchers(setting: *mut NMSettingTeam);
    pub fn nm_setting_team_get_config(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_link_watcher(setting: *mut NMSettingTeam, idx: c_uint) -> *mut NMTeamLinkWatcher;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_mcast_rejoin_count(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_mcast_rejoin_interval(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_notify_peers_count(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_notify_peers_interval(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_num_link_watchers(setting: *mut NMSettingTeam) -> c_uint;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_num_runner_tx_hash(setting: *mut NMSettingTeam) -> c_uint;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner_active(setting: *mut NMSettingTeam) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner_agg_select_policy(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner_fast_rate(setting: *mut NMSettingTeam) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner_hwaddr_policy(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner_min_ports(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner_sys_prio(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner_tx_balancer(setting: *mut NMSettingTeam) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner_tx_balancer_interval(setting: *mut NMSettingTeam) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_get_runner_tx_hash(setting: *mut NMSettingTeam, idx: c_uint) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_remove_link_watcher(setting: *mut NMSettingTeam, idx: c_uint);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_remove_link_watcher_by_value(setting: *mut NMSettingTeam, link_watcher: *mut NMTeamLinkWatcher) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_remove_runner_tx_hash(setting: *mut NMSettingTeam, idx: c_uint);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_remove_runner_tx_hash_by_value(setting: *mut NMSettingTeam, txhash: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingTeamPort
    //=========================================================================
    pub fn nm_setting_team_port_get_type() -> GType;
    pub fn nm_setting_team_port_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_add_link_watcher(setting: *mut NMSettingTeamPort, link_watcher: *mut NMTeamLinkWatcher) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_clear_link_watchers(setting: *mut NMSettingTeamPort);
    pub fn nm_setting_team_port_get_config(setting: *mut NMSettingTeamPort) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_get_lacp_key(setting: *mut NMSettingTeamPort) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_get_lacp_prio(setting: *mut NMSettingTeamPort) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_get_link_watcher(setting: *mut NMSettingTeamPort, idx: c_uint) -> *mut NMTeamLinkWatcher;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_get_num_link_watchers(setting: *mut NMSettingTeamPort) -> c_uint;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_get_prio(setting: *mut NMSettingTeamPort) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_get_queue_id(setting: *mut NMSettingTeamPort) -> c_int;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_get_sticky(setting: *mut NMSettingTeamPort) -> gboolean;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_remove_link_watcher(setting: *mut NMSettingTeamPort, idx: c_uint);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_team_port_remove_link_watcher_by_value(setting: *mut NMSettingTeamPort, link_watcher: *mut NMTeamLinkWatcher) -> gboolean;

    //=========================================================================
    // NMSettingTun
    //=========================================================================
    pub fn nm_setting_tun_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_group(setting: *mut NMSettingTun) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_mode(setting: *mut NMSettingTun) -> NMSettingTunMode;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_multi_queue(setting: *mut NMSettingTun) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_owner(setting: *mut NMSettingTun) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_pi(setting: *mut NMSettingTun) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_vnet_hdr(setting: *mut NMSettingTun) -> gboolean;

    //=========================================================================
    // NMSettingUser
    //=========================================================================
    pub fn nm_setting_user_get_type() -> GType;
    pub fn nm_setting_user_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_user_check_key(key: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_user_check_val(val: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_user_get_data(setting: *mut NMSettingUser, key: *const c_char) -> *const c_char;
    pub fn nm_setting_user_get_keys(setting: *mut NMSettingUser, out_len: *mut c_uint) -> *const *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_user_set_data(setting: *mut NMSettingUser, key: *const c_char, val: *const c_char, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSettingVlan
    //=========================================================================
    pub fn nm_setting_vlan_get_type() -> GType;
    pub fn nm_setting_vlan_new() -> *mut NMSetting;
    pub fn nm_setting_vlan_add_priority(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, from: u32, to: u32) -> gboolean;
    pub fn nm_setting_vlan_add_priority_str(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, str: *const c_char) -> gboolean;
    pub fn nm_setting_vlan_clear_priorities(setting: *mut NMSettingVlan, map: NMVlanPriorityMap);
    pub fn nm_setting_vlan_get_flags(setting: *mut NMSettingVlan) -> u32;
    pub fn nm_setting_vlan_get_id(setting: *mut NMSettingVlan) -> u32;
    pub fn nm_setting_vlan_get_num_priorities(setting: *mut NMSettingVlan, map: NMVlanPriorityMap) -> i32;
    pub fn nm_setting_vlan_get_parent(setting: *mut NMSettingVlan) -> *const c_char;
    pub fn nm_setting_vlan_get_priority(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, idx: u32, out_from: *mut u32, out_to: *mut u32) -> gboolean;
    pub fn nm_setting_vlan_remove_priority(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, idx: u32);
    pub fn nm_setting_vlan_remove_priority_by_value(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, from: u32, to: u32) -> gboolean;
    pub fn nm_setting_vlan_remove_priority_str_by_value(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, str: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingVpn
    //=========================================================================
    pub fn nm_setting_vpn_get_type() -> GType;
    pub fn nm_setting_vpn_new() -> *mut NMSetting;
    pub fn nm_setting_vpn_add_data_item(setting: *mut NMSettingVpn, key: *const c_char, item: *const c_char);
    pub fn nm_setting_vpn_add_secret(setting: *mut NMSettingVpn, key: *const c_char, secret: *const c_char);
    pub fn nm_setting_vpn_foreach_data_item(setting: *mut NMSettingVpn, func: NMVpnIterFunc, user_data: gpointer);
    pub fn nm_setting_vpn_foreach_secret(setting: *mut NMSettingVpn, func: NMVpnIterFunc, user_data: gpointer);
    pub fn nm_setting_vpn_get_data_item(setting: *mut NMSettingVpn, key: *const c_char) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_vpn_get_data_keys(setting: *mut NMSettingVpn, out_length: *mut c_uint) -> *mut *const c_char;
    pub fn nm_setting_vpn_get_num_data_items(setting: *mut NMSettingVpn) -> u32;
    pub fn nm_setting_vpn_get_num_secrets(setting: *mut NMSettingVpn) -> u32;
    pub fn nm_setting_vpn_get_persistent(setting: *mut NMSettingVpn) -> gboolean;
    pub fn nm_setting_vpn_get_secret(setting: *mut NMSettingVpn, key: *const c_char) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_vpn_get_secret_keys(setting: *mut NMSettingVpn, out_length: *mut c_uint) -> *mut *const c_char;
    pub fn nm_setting_vpn_get_service_type(setting: *mut NMSettingVpn) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vpn_get_timeout(setting: *mut NMSettingVpn) -> u32;
    pub fn nm_setting_vpn_get_user_name(setting: *mut NMSettingVpn) -> *const c_char;
    pub fn nm_setting_vpn_remove_data_item(setting: *mut NMSettingVpn, key: *const c_char) -> gboolean;
    pub fn nm_setting_vpn_remove_secret(setting: *mut NMSettingVpn, key: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingVrf
    //=========================================================================
    pub fn nm_setting_vrf_get_type() -> GType;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_setting_vrf_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_24", feature = "dox"))]
    pub fn nm_setting_vrf_get_table(setting: *mut NMSettingVrf) -> u32;

    //=========================================================================
    // NMSettingVxlan
    //=========================================================================
    pub fn nm_setting_vxlan_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_ageing(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_destination_port(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_id(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_l2_miss(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_l3_miss(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_learning(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_limit(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_local(setting: *mut NMSettingVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_parent(setting: *mut NMSettingVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_proxy(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_remote(setting: *mut NMSettingVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_rsc(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_source_port_max(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_source_port_min(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_tos(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_ttl(setting: *mut NMSettingVxlan) -> c_uint;

    //=========================================================================
    // NMSettingWifiP2P
    //=========================================================================
    pub fn nm_setting_wifi_p2p_get_type() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wifi_p2p_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wifi_p2p_get_peer(setting: *mut NMSettingWifiP2P) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wifi_p2p_get_wfd_ies(setting: *mut NMSettingWifiP2P) -> *mut glib::GBytes;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wifi_p2p_get_wps_method(setting: *mut NMSettingWifiP2P) -> NMSettingWirelessSecurityWpsMethod;

    //=========================================================================
    // NMSettingWimax
    //=========================================================================
    pub fn nm_setting_wimax_get_type() -> GType;
    pub fn nm_setting_wimax_new() -> *mut NMSetting;
    pub fn nm_setting_wimax_get_mac_address(setting: *mut NMSettingWimax) -> *const c_char;
    pub fn nm_setting_wimax_get_network_name(setting: *mut NMSettingWimax) -> *const c_char;

    //=========================================================================
    // NMSettingWireGuard
    //=========================================================================
    pub fn nm_setting_wireguard_get_type() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_append_peer(self_: *mut NMSettingWireGuard, peer: *mut NMWireGuardPeer);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_clear_peers(self_: *mut NMSettingWireGuard) -> c_uint;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_get_fwmark(self_: *mut NMSettingWireGuard) -> u32;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_setting_wireguard_get_ip4_auto_default_route(self_: *mut NMSettingWireGuard) -> NMTernary;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_setting_wireguard_get_ip6_auto_default_route(self_: *mut NMSettingWireGuard) -> NMTernary;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_get_listen_port(self_: *mut NMSettingWireGuard) -> u16;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_get_mtu(self_: *mut NMSettingWireGuard) -> u32;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_get_peer(self_: *mut NMSettingWireGuard, idx: c_uint) -> *mut NMWireGuardPeer;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_get_peer_by_public_key(self_: *mut NMSettingWireGuard, public_key: *const c_char, out_idx: *mut c_uint) -> *mut NMWireGuardPeer;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_get_peer_routes(self_: *mut NMSettingWireGuard) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_get_peers_len(self_: *mut NMSettingWireGuard) -> c_uint;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_get_private_key(self_: *mut NMSettingWireGuard) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_get_private_key_flags(self_: *mut NMSettingWireGuard) -> NMSettingSecretFlags;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_remove_peer(self_: *mut NMSettingWireGuard, idx: c_uint) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wireguard_set_peer(self_: *mut NMSettingWireGuard, peer: *mut NMWireGuardPeer, idx: c_uint);

    //=========================================================================
    // NMSettingWired
    //=========================================================================
    pub fn nm_setting_wired_get_type() -> GType;
    pub fn nm_setting_wired_new() -> *mut NMSetting;
    pub fn nm_setting_wired_add_mac_blacklist_item(setting: *mut NMSettingWired, mac: *const c_char) -> gboolean;
    pub fn nm_setting_wired_add_s390_option(setting: *mut NMSettingWired, key: *const c_char, value: *const c_char) -> gboolean;
    pub fn nm_setting_wired_clear_mac_blacklist_items(setting: *mut NMSettingWired);
    pub fn nm_setting_wired_get_auto_negotiate(setting: *mut NMSettingWired) -> gboolean;
    pub fn nm_setting_wired_get_cloned_mac_address(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_duplex(setting: *mut NMSettingWired) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_wired_get_generate_mac_address_mask(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_mac_address(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_mac_address_blacklist(setting: *mut NMSettingWired) -> *const *const c_char;
    pub fn nm_setting_wired_get_mac_blacklist_item(setting: *mut NMSettingWired, idx: u32) -> *const c_char;
    pub fn nm_setting_wired_get_mtu(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_num_mac_blacklist_items(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_num_s390_options(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_port(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_s390_nettype(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_s390_option_by_key(setting: *mut NMSettingWired, key: *const c_char) -> *const c_char;
    pub fn nm_setting_wired_get_s390_subchannels(setting: *mut NMSettingWired) -> *const *const c_char;
    pub fn nm_setting_wired_get_speed(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_valid_s390_options(setting: *mut NMSettingWired) -> *mut *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_wired_get_wake_on_lan(setting: *mut NMSettingWired) -> NMSettingWiredWakeOnLan;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_wired_get_wake_on_lan_password(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_remove_mac_blacklist_item(setting: *mut NMSettingWired, idx: u32);
    pub fn nm_setting_wired_remove_mac_blacklist_item_by_value(setting: *mut NMSettingWired, mac: *const c_char) -> gboolean;
    pub fn nm_setting_wired_remove_s390_option(setting: *mut NMSettingWired, key: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingWireless
    //=========================================================================
    pub fn nm_setting_wireless_get_type() -> GType;
    pub fn nm_setting_wireless_new() -> *mut NMSetting;
    pub fn nm_setting_wireless_add_mac_blacklist_item(setting: *mut NMSettingWireless, mac: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_add_seen_bssid(setting: *mut NMSettingWireless, bssid: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_ap_security_compatible(s_wireless: *mut NMSettingWireless, s_wireless_sec: *mut NMSettingWirelessSecurity, ap_flags: NM80211ApFlags, ap_wpa: NM80211ApSecurityFlags, ap_rsn: NM80211ApSecurityFlags, ap_mode: NM80211Mode) -> gboolean;
    pub fn nm_setting_wireless_clear_mac_blacklist_items(setting: *mut NMSettingWireless);
    pub fn nm_setting_wireless_get_band(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_bssid(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_channel(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_cloned_mac_address(setting: *mut NMSettingWireless) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_wireless_get_generate_mac_address_mask(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_hidden(setting: *mut NMSettingWireless) -> gboolean;
    pub fn nm_setting_wireless_get_mac_address(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_mac_address_blacklist(setting: *mut NMSettingWireless) -> *const *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_wireless_get_mac_address_randomization(setting: *mut NMSettingWireless) -> NMSettingMacRandomization;
    pub fn nm_setting_wireless_get_mac_blacklist_item(setting: *mut NMSettingWireless, idx: u32) -> *const c_char;
    pub fn nm_setting_wireless_get_mode(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_mtu(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_num_mac_blacklist_items(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_num_seen_bssids(setting: *mut NMSettingWireless) -> u32;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_wireless_get_powersave(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_rate(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_seen_bssid(setting: *mut NMSettingWireless, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_get_ssid(setting: *mut NMSettingWireless) -> *mut glib::GBytes;
    pub fn nm_setting_wireless_get_tx_power(setting: *mut NMSettingWireless) -> u32;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_wireless_get_wake_on_wlan(setting: *mut NMSettingWireless) -> NMSettingWirelessWakeOnWLan;
    pub fn nm_setting_wireless_remove_mac_blacklist_item(setting: *mut NMSettingWireless, idx: u32);
    pub fn nm_setting_wireless_remove_mac_blacklist_item_by_value(setting: *mut NMSettingWireless, mac: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingWirelessSecurity
    //=========================================================================
    pub fn nm_setting_wireless_security_get_type() -> GType;
    pub fn nm_setting_wireless_security_new() -> *mut NMSetting;
    pub fn nm_setting_wireless_security_add_group(setting: *mut NMSettingWirelessSecurity, group: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_add_pairwise(setting: *mut NMSettingWirelessSecurity, pairwise: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_add_proto(setting: *mut NMSettingWirelessSecurity, proto: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_clear_groups(setting: *mut NMSettingWirelessSecurity);
    pub fn nm_setting_wireless_security_clear_pairwise(setting: *mut NMSettingWirelessSecurity);
    pub fn nm_setting_wireless_security_clear_protos(setting: *mut NMSettingWirelessSecurity);
    pub fn nm_setting_wireless_security_get_auth_alg(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_setting_wireless_security_get_fils(setting: *mut NMSettingWirelessSecurity) -> NMSettingWirelessSecurityFils;
    pub fn nm_setting_wireless_security_get_group(setting: *mut NMSettingWirelessSecurity, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_key_mgmt(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_leap_password(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_leap_password_flags(setting: *mut NMSettingWirelessSecurity) -> NMSettingSecretFlags;
    pub fn nm_setting_wireless_security_get_leap_username(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_num_groups(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_get_num_pairwise(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_get_num_protos(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_get_pairwise(setting: *mut NMSettingWirelessSecurity, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_pmf(setting: *mut NMSettingWirelessSecurity) -> NMSettingWirelessSecurityPmf;
    pub fn nm_setting_wireless_security_get_proto(setting: *mut NMSettingWirelessSecurity, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_psk(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_psk_flags(setting: *mut NMSettingWirelessSecurity) -> NMSettingSecretFlags;
    pub fn nm_setting_wireless_security_get_wep_key(setting: *mut NMSettingWirelessSecurity, idx: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_wep_key_flags(setting: *mut NMSettingWirelessSecurity) -> NMSettingSecretFlags;
    pub fn nm_setting_wireless_security_get_wep_key_type(setting: *mut NMSettingWirelessSecurity) -> NMWepKeyType;
    pub fn nm_setting_wireless_security_get_wep_tx_keyidx(setting: *mut NMSettingWirelessSecurity) -> u32;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_setting_wireless_security_get_wps_method(setting: *mut NMSettingWirelessSecurity) -> NMSettingWirelessSecurityWpsMethod;
    pub fn nm_setting_wireless_security_remove_group(setting: *mut NMSettingWirelessSecurity, i: u32);
    pub fn nm_setting_wireless_security_remove_group_by_value(setting: *mut NMSettingWirelessSecurity, group: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_remove_pairwise(setting: *mut NMSettingWirelessSecurity, i: u32);
    pub fn nm_setting_wireless_security_remove_pairwise_by_value(setting: *mut NMSettingWirelessSecurity, pairwise: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_remove_proto(setting: *mut NMSettingWirelessSecurity, i: u32);
    pub fn nm_setting_wireless_security_remove_proto_by_value(setting: *mut NMSettingWirelessSecurity, proto: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_set_wep_key(setting: *mut NMSettingWirelessSecurity, idx: u32, key: *const c_char);

    //=========================================================================
    // NMSettingWpan
    //=========================================================================
    pub fn nm_setting_wpan_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_wpan_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wpan_get_channel(setting: *mut NMSettingWpan) -> i16;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_wpan_get_mac_address(setting: *mut NMSettingWpan) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_setting_wpan_get_page(setting: *mut NMSettingWpan) -> i16;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_wpan_get_pan_id(setting: *mut NMSettingWpan) -> u16;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_setting_wpan_get_short_address(setting: *mut NMSettingWpan) -> u16;

    //=========================================================================
    // NMSimpleConnection
    //=========================================================================
    pub fn nm_simple_connection_get_type() -> GType;
    pub fn nm_simple_connection_new() -> *mut NMConnection;
    pub fn nm_simple_connection_new_clone(connection: *mut NMConnection) -> *mut NMConnection;
    pub fn nm_simple_connection_new_from_dbus(dict: *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut NMConnection;

    //=========================================================================
    // NMVpnConnection
    //=========================================================================
    pub fn nm_vpn_connection_get_type() -> GType;
    pub fn nm_vpn_connection_get_banner(vpn: *mut NMVpnConnection) -> *const c_char;
    pub fn nm_vpn_connection_get_vpn_state(vpn: *mut NMVpnConnection) -> NMVpnConnectionState;

    //=========================================================================
    // NMVpnPluginInfo
    //=========================================================================
    pub fn nm_vpn_plugin_info_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_new_from_file(filename: *const c_char, error: *mut *mut glib::GError) -> *mut NMVpnPluginInfo;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_new_search_file(name: *const c_char, service: *const c_char) -> *mut NMVpnPluginInfo;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_new_with_data(filename: *const c_char, keyfile: *mut glib::GKeyFile, error: *mut *mut glib::GError) -> *mut NMVpnPluginInfo;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_validate_filename(filename: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_aliases(self_: *mut NMVpnPluginInfo) -> *const *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_auth_dialog(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_editor_plugin(self_: *mut NMVpnPluginInfo) -> *mut NMVpnEditorPlugin;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_filename(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_name(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_plugin(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_program(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_service(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_load_editor_plugin(self_: *mut NMVpnPluginInfo, error: *mut *mut glib::GError) -> *mut NMVpnEditorPlugin;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_lookup_property(self_: *mut NMVpnPluginInfo, group: *const c_char, key: *const c_char) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_set_editor_plugin(self_: *mut NMVpnPluginInfo, plugin: *mut NMVpnEditorPlugin);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_supports_hints(self_: *mut NMVpnPluginInfo) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_supports_multiple(self_: *mut NMVpnPluginInfo) -> gboolean;

    //=========================================================================
    // NMVpnPluginOld
    //=========================================================================
    pub fn nm_vpn_plugin_old_get_type() -> GType;
    pub fn nm_vpn_plugin_old_get_secret_flags(data: *mut glib::GHashTable, secret_name: *const c_char, out_flags: *mut NMSettingSecretFlags) -> gboolean;
    pub fn nm_vpn_plugin_old_read_vpn_details(fd: c_int, out_data: *mut *mut glib::GHashTable, out_secrets: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_vpn_plugin_old_disconnect(plugin: *mut NMVpnPluginOld, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_vpn_plugin_old_failure(plugin: *mut NMVpnPluginOld, reason: NMVpnPluginFailure);
    pub fn nm_vpn_plugin_old_get_state(plugin: *mut NMVpnPluginOld) -> NMVpnServiceState;
    pub fn nm_vpn_plugin_old_set_config(plugin: *mut NMVpnPluginOld, config: *mut glib::GVariant);
    pub fn nm_vpn_plugin_old_set_ip4_config(plugin: *mut NMVpnPluginOld, ip4_config: *mut glib::GVariant);
    pub fn nm_vpn_plugin_old_set_ip6_config(plugin: *mut NMVpnPluginOld, ip6_config: *mut glib::GVariant);
    pub fn nm_vpn_plugin_old_set_login_banner(plugin: *mut NMVpnPluginOld, banner: *const c_char);
    pub fn nm_vpn_plugin_old_set_state(plugin: *mut NMVpnPluginOld, state: NMVpnServiceState);

    //=========================================================================
    // NMVpnServicePlugin
    //=========================================================================
    pub fn nm_vpn_service_plugin_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_service_plugin_get_secret_flags(data: *mut glib::GHashTable, secret_name: *const c_char, out_flags: *mut NMSettingSecretFlags) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_service_plugin_read_vpn_details(fd: c_int, out_data: *mut *mut glib::GHashTable, out_secrets: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_vpn_service_plugin_disconnect(plugin: *mut NMVpnServicePlugin, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_vpn_service_plugin_failure(plugin: *mut NMVpnServicePlugin, reason: NMVpnPluginFailure);
    pub fn nm_vpn_service_plugin_set_config(plugin: *mut NMVpnServicePlugin, config: *mut glib::GVariant);
    pub fn nm_vpn_service_plugin_set_ip4_config(plugin: *mut NMVpnServicePlugin, ip4_config: *mut glib::GVariant);
    pub fn nm_vpn_service_plugin_set_ip6_config(plugin: *mut NMVpnServicePlugin, ip6_config: *mut glib::GVariant);
    pub fn nm_vpn_service_plugin_set_login_banner(plugin: *mut NMVpnServicePlugin, banner: *const c_char);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_vpn_service_plugin_shutdown(plugin: *mut NMVpnServicePlugin);

    //=========================================================================
    // NMWifiP2PPeer
    //=========================================================================
    pub fn nm_wifi_p2p_peer_get_type() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_connection_valid(peer: *mut NMWifiP2PPeer, connection: *mut NMConnection) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_filter_connections(peer: *mut NMWifiP2PPeer, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_flags(peer: *mut NMWifiP2PPeer) -> NM80211ApFlags;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_hw_address(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_last_seen(peer: *mut NMWifiP2PPeer) -> c_int;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_manufacturer(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_model(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_model_number(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_name(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_serial(peer: *mut NMWifiP2PPeer) -> *const c_char;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_strength(peer: *mut NMWifiP2PPeer) -> u8;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    pub fn nm_wifi_p2p_peer_get_wfd_ies(peer: *mut NMWifiP2PPeer) -> *mut glib::GBytes;

    //=========================================================================
    // NMWimaxNsp
    //=========================================================================
    pub fn nm_wimax_nsp_get_type() -> GType;
    pub fn nm_wimax_nsp_connection_valid(nsp: *mut NMWimaxNsp, connection: *mut NMConnection) -> gboolean;
    pub fn nm_wimax_nsp_filter_connections(nsp: *mut NMWimaxNsp, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    pub fn nm_wimax_nsp_get_name(nsp: *mut NMWimaxNsp) -> *const c_char;
    pub fn nm_wimax_nsp_get_network_type(nsp: *mut NMWimaxNsp) -> NMWimaxNspNetworkType;
    pub fn nm_wimax_nsp_get_signal_quality(nsp: *mut NMWimaxNsp) -> u32;

    //=========================================================================
    // NMConnection
    //=========================================================================
    pub fn nm_connection_get_type() -> GType;
    pub fn nm_connection_add_setting(connection: *mut NMConnection, setting: *mut NMSetting);
    pub fn nm_connection_clear_secrets(connection: *mut NMConnection);
    pub fn nm_connection_clear_settings(connection: *mut NMConnection);
    pub fn nm_connection_compare(a: *mut NMConnection, b: *mut NMConnection, flags: NMSettingCompareFlags) -> gboolean;
    pub fn nm_connection_diff(a: *mut NMConnection, b: *mut NMConnection, flags: NMSettingCompareFlags, out_settings: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_connection_dump(connection: *mut NMConnection);
    pub fn nm_connection_for_each_setting_value(connection: *mut NMConnection, func: NMSettingValueIterFn, user_data: gpointer);
    pub fn nm_connection_get_connection_type(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_id(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_interface_name(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_path(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_setting(connection: *mut NMConnection, setting_type: GType) -> *mut NMSetting;
    pub fn nm_connection_get_setting_802_1x(connection: *mut NMConnection) -> *mut NMSetting8021x;
    pub fn nm_connection_get_setting_adsl(connection: *mut NMConnection) -> *mut NMSettingAdsl;
    pub fn nm_connection_get_setting_bluetooth(connection: *mut NMConnection) -> *mut NMSettingBluetooth;
    pub fn nm_connection_get_setting_bond(connection: *mut NMConnection) -> *mut NMSettingBond;
    pub fn nm_connection_get_setting_bridge(connection: *mut NMConnection) -> *mut NMSettingBridge;
    pub fn nm_connection_get_setting_bridge_port(connection: *mut NMConnection) -> *mut NMSettingBridgePort;
    pub fn nm_connection_get_setting_by_name(connection: *mut NMConnection, name: *const c_char) -> *mut NMSetting;
    pub fn nm_connection_get_setting_cdma(connection: *mut NMConnection) -> *mut NMSettingCdma;
    pub fn nm_connection_get_setting_connection(connection: *mut NMConnection) -> *mut NMSettingConnection;
    pub fn nm_connection_get_setting_dcb(connection: *mut NMConnection) -> *mut NMSettingDcb;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_connection_get_setting_dummy(connection: *mut NMConnection) -> *mut NMSettingDummy;
    pub fn nm_connection_get_setting_generic(connection: *mut NMConnection) -> *mut NMSettingGeneric;
    pub fn nm_connection_get_setting_gsm(connection: *mut NMConnection) -> *mut NMSettingGsm;
    pub fn nm_connection_get_setting_infiniband(connection: *mut NMConnection) -> *mut NMSettingInfiniband;
    pub fn nm_connection_get_setting_ip4_config(connection: *mut NMConnection) -> *mut NMSettingIP4Config;
    pub fn nm_connection_get_setting_ip6_config(connection: *mut NMConnection) -> *mut NMSettingIP6Config;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_get_setting_ip_tunnel(connection: *mut NMConnection) -> *mut NMSettingIPTunnel;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_connection_get_setting_macsec(connection: *mut NMConnection) -> *mut NMSettingMacsec;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_get_setting_macvlan(connection: *mut NMConnection) -> *mut NMSettingMacvlan;
    pub fn nm_connection_get_setting_olpc_mesh(connection: *mut NMConnection) -> *mut NMSettingOlpcMesh;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_connection_get_setting_ovs_bridge(connection: *mut NMConnection) -> *mut NMSettingOvsBridge;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_connection_get_setting_ovs_interface(connection: *mut NMConnection) -> *mut NMSettingOvsInterface;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_connection_get_setting_ovs_patch(connection: *mut NMConnection) -> *mut NMSettingOvsPatch;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_connection_get_setting_ovs_port(connection: *mut NMConnection) -> *mut NMSettingOvsPort;
    pub fn nm_connection_get_setting_ppp(connection: *mut NMConnection) -> *mut NMSettingPpp;
    pub fn nm_connection_get_setting_pppoe(connection: *mut NMConnection) -> *mut NMSettingPppoe;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_connection_get_setting_proxy(connection: *mut NMConnection) -> *mut NMSettingProxy;
    pub fn nm_connection_get_setting_serial(connection: *mut NMConnection) -> *mut NMSettingSerial;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_connection_get_setting_tc_config(connection: *mut NMConnection) -> *mut NMSettingTCConfig;
    pub fn nm_connection_get_setting_team(connection: *mut NMConnection) -> *mut NMSettingTeam;
    pub fn nm_connection_get_setting_team_port(connection: *mut NMConnection) -> *mut NMSettingTeamPort;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_get_setting_tun(connection: *mut NMConnection) -> *mut NMSettingTun;
    pub fn nm_connection_get_setting_vlan(connection: *mut NMConnection) -> *mut NMSettingVlan;
    pub fn nm_connection_get_setting_vpn(connection: *mut NMConnection) -> *mut NMSettingVpn;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_get_setting_vxlan(connection: *mut NMConnection) -> *mut NMSettingVxlan;
    pub fn nm_connection_get_setting_wimax(connection: *mut NMConnection) -> *mut NMSettingWimax;
    pub fn nm_connection_get_setting_wired(connection: *mut NMConnection) -> *mut NMSettingWired;
    pub fn nm_connection_get_setting_wireless(connection: *mut NMConnection) -> *mut NMSettingWireless;
    pub fn nm_connection_get_setting_wireless_security(connection: *mut NMConnection) -> *mut NMSettingWirelessSecurity;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn nm_connection_get_settings(connection: *mut NMConnection, out_length: *mut c_uint) -> *mut *mut NMSetting;
    pub fn nm_connection_get_uuid(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_virtual_device_description(connection: *mut NMConnection) -> *mut c_char;
    pub fn nm_connection_is_type(connection: *mut NMConnection, type_: *const c_char) -> gboolean;
    pub fn nm_connection_is_virtual(connection: *mut NMConnection) -> gboolean;
    pub fn nm_connection_need_secrets(connection: *mut NMConnection, hints: *mut *mut glib::GPtrArray) -> *const c_char;
    pub fn nm_connection_normalize(connection: *mut NMConnection, parameters: *mut glib::GHashTable, modified: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_connection_remove_setting(connection: *mut NMConnection, setting_type: GType);
    pub fn nm_connection_replace_settings(connection: *mut NMConnection, new_settings: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_connection_replace_settings_from_connection(connection: *mut NMConnection, new_connection: *mut NMConnection);
    pub fn nm_connection_set_path(connection: *mut NMConnection, path: *const c_char);
    pub fn nm_connection_to_dbus(connection: *mut NMConnection, flags: NMConnectionSerializationFlags) -> *mut glib::GVariant;
    pub fn nm_connection_update_secrets(connection: *mut NMConnection, setting_name: *const c_char, secrets: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_connection_verify(connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_verify_secrets(connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMVpnEditor
    //=========================================================================
    pub fn nm_vpn_editor_get_type() -> GType;
    pub fn nm_vpn_editor_get_widget(editor: *mut NMVpnEditor) -> *mut gobject::GObject;
    pub fn nm_vpn_editor_update_connection(editor: *mut NMVpnEditor, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMVpnEditorPlugin
    //=========================================================================
    pub fn nm_vpn_editor_plugin_get_type() -> GType;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_load(plugin_name: *const c_char, check_service: *const c_char, error: *mut *mut glib::GError) -> *mut NMVpnEditorPlugin;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_load_from_file(plugin_name: *const c_char, check_service: *const c_char, check_owner: c_int, check_file: NMUtilsCheckFilePredicate, user_data: gpointer, error: *mut *mut glib::GError) -> *mut NMVpnEditorPlugin;
    pub fn nm_vpn_editor_plugin_export(plugin: *mut NMVpnEditorPlugin, path: *const c_char, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_vpn_editor_plugin_get_capabilities(plugin: *mut NMVpnEditorPlugin) -> NMVpnEditorPluginCapability;
    pub fn nm_vpn_editor_plugin_get_editor(plugin: *mut NMVpnEditorPlugin, connection: *mut NMConnection, error: *mut *mut glib::GError) -> *mut NMVpnEditor;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_get_plugin_info(plugin: *mut NMVpnEditorPlugin) -> *mut NMVpnPluginInfo;
    pub fn nm_vpn_editor_plugin_get_suggested_filename(plugin: *mut NMVpnEditorPlugin, connection: *mut NMConnection) -> *mut c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_get_vt(plugin: *mut NMVpnEditorPlugin, vt: *mut NMVpnEditorPluginVT, vt_size: size_t) -> size_t;
    pub fn nm_vpn_editor_plugin_import(plugin: *mut NMVpnEditorPlugin, path: *const c_char, error: *mut *mut glib::GError) -> *mut NMConnection;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_set_plugin_info(plugin: *mut NMVpnEditorPlugin, plugin_info: *mut NMVpnPluginInfo);

    //=========================================================================
    // Other functions
    //=========================================================================
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    pub fn nm_ethtool_optname_is_feature(optname: *const c_char) -> gboolean;
    pub fn nm_utils_ap_mode_security_valid(type_: NMUtilsSecurityType, wifi_caps: NMDeviceWifiCapabilities) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_bond_mode_int_to_string(mode: c_int) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_bond_mode_string_to_int(mode: *const c_char) -> c_int;
    pub fn nm_utils_check_virtual_device_compatibility(virtual_type: GType, other_type: GType) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_enum_get_values(type_: GType, from: c_int, to: c_int) -> *mut *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_enum_to_str(type_: GType, value: c_int) -> *mut c_char;
    pub fn nm_utils_escape_ssid(ssid: *const u8, len: size_t) -> *const c_char;
    pub fn nm_utils_file_is_certificate(filename: *const c_char) -> gboolean;
    pub fn nm_utils_file_is_pkcs12(filename: *const c_char) -> gboolean;
    pub fn nm_utils_file_is_private_key(filename: *const c_char, out_encrypted: *mut gboolean) -> gboolean;
    pub fn nm_utils_format_variant_attributes(attributes: *mut glib::GHashTable, attr_separator: c_char, key_value_separator: c_char) -> *mut c_char;
    pub fn nm_utils_get_timestamp_msec() -> i64;
    pub fn nm_utils_hexstr2bin(hex: *const c_char) -> *mut glib::GBytes;
    pub fn nm_utils_hwaddr_atoba(asc: *const c_char, length: size_t) -> *mut glib::GByteArray;
    pub fn nm_utils_hwaddr_canonical(asc: *const c_char, length: ssize_t) -> *mut c_char;
    pub fn nm_utils_hwaddr_len(type_: c_int) -> size_t;
    pub fn nm_utils_hwaddr_matches(hwaddr1: gconstpointer, hwaddr1_len: ssize_t, hwaddr2: gconstpointer, hwaddr2_len: ssize_t) -> gboolean;
    pub fn nm_utils_hwaddr_valid(asc: *const c_char, length: ssize_t) -> gboolean;
    pub fn nm_utils_iface_valid_name(name: *const c_char) -> gboolean;
    pub fn nm_utils_inet4_ntop(dst: *mut c_char) -> *const c_char;
    pub fn nm_utils_inet6_ntop(dst: *mut c_char) -> *const c_char;
    pub fn nm_utils_ip4_addresses_to_variant(addresses: *mut glib::GPtrArray, gateway: *const c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip4_get_default_prefix(ip: u32) -> u32;
    pub fn nm_utils_ip4_netmask_to_prefix(netmask: u32) -> u32;
    pub fn nm_utils_ip4_prefix_to_netmask(prefix: u32) -> u32;
    pub fn nm_utils_ip4_routes_from_variant(value: *mut glib::GVariant) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip4_routes_to_variant(routes: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ip6_addresses_to_variant(addresses: *mut glib::GPtrArray, gateway: *const c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip6_routes_from_variant(value: *mut glib::GVariant) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip6_routes_to_variant(routes: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ip_addresses_from_variant(value: *mut glib::GVariant, family: c_int) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip_addresses_to_variant(addresses: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ip_routes_from_variant(value: *mut glib::GVariant, family: c_int) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip_routes_to_variant(routes: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ipaddr_valid(family: c_int, ip: *const c_char) -> gboolean;
    pub fn nm_utils_is_empty_ssid(ssid: *const u8, len: size_t) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_utils_is_json_object(str: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_utils_is_uuid(str: *const c_char) -> gboolean;
    pub fn nm_utils_is_valid_iface_name(name: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_utils_parse_variant_attributes(string: *const c_char, attr_separator: c_char, key_value_separator: c_char, ignore_unknown: gboolean, spec: *const *const NMVariantAttributeSpec, error: *mut *mut glib::GError) -> *mut glib::GHashTable;
    pub fn nm_utils_same_ssid(ssid1: *const u8, len1: size_t, ssid2: *const u8, len2: size_t, ignore_trailing_null: gboolean) -> gboolean;
    pub fn nm_utils_security_valid(type_: NMUtilsSecurityType, wifi_caps: NMDeviceWifiCapabilities, have_ap: gboolean, adhoc: gboolean, ap_flags: NM80211ApFlags, ap_wpa: NM80211ApSecurityFlags, ap_rsn: NM80211ApSecurityFlags) -> gboolean;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_utils_sriov_vf_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMSriovVF;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn nm_utils_sriov_vf_to_str(vf: *const NMSriovVF, omit_index: gboolean, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn nm_utils_ssid_to_utf8(ssid: *const u8, len: size_t) -> *mut c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_utils_tc_qdisc_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMTCQdisc;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_utils_tc_qdisc_to_str(qdisc: *mut NMTCQdisc, error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_utils_tc_tfilter_from_str(str: *const c_char, error: *mut *mut glib::GError) -> *mut NMTCTfilter;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn nm_utils_tc_tfilter_to_str(tfilter: *mut NMTCTfilter, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn nm_utils_uuid_generate() -> *mut c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_utils_version() -> c_uint;
    pub fn nm_utils_wep_key_valid(key: *const c_char, wep_type: NMWepKeyType) -> gboolean;
    pub fn nm_utils_wifi_channel_to_freq(channel: u32, band: *const c_char) -> u32;
    pub fn nm_utils_wifi_find_next_channel(channel: u32, direction: c_int, band: *mut c_char) -> u32;
    pub fn nm_utils_wifi_freq_to_channel(freq: u32) -> u32;
    pub fn nm_utils_wifi_is_channel_valid(channel: u32, band: *const c_char) -> gboolean;
    pub fn nm_utils_wifi_strength_bars(strength: u8) -> *const c_char;
    pub fn nm_utils_wpa_psk_valid(psk: *const c_char) -> gboolean;

}
