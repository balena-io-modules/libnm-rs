// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use nm_sys;

#[cfg(any(feature = "v1_10", feature = "dox"))]
bitflags! {
    pub struct ActivationStateFlags: u32 {
        const NONE = 0;
        const IS_MASTER = 1;
        const IS_SLAVE = 2;
        const LAYER2_READY = 4;
        const IP4_READY = 8;
        const IP6_READY = 16;
        const MASTER_HAS_SLAVES = 32;
        const LIFETIME_BOUND_TO_PROFILE_VISIBILITY = 64;
        const EXTERNAL = 128;
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for ActivationStateFlags {
    type GlibType = nm_sys::NMActivationStateFlags;

    fn to_glib(&self) -> nm_sys::NMActivationStateFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMActivationStateFlags> for ActivationStateFlags {
    fn from_glib(value: nm_sys::NMActivationStateFlags) -> ActivationStateFlags {
        ActivationStateFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl StaticType for ActivationStateFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_activation_state_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl<'a> FromValueOptional<'a> for ActivationStateFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl<'a> FromValue<'a> for ActivationStateFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl SetValue for ActivationStateFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct BluetoothCapabilities: u32 {
        const NONE = 0;
        const DUN = 1;
        const NAP = 2;
    }
}

#[doc(hidden)]
impl ToGlib for BluetoothCapabilities {
    type GlibType = nm_sys::NMBluetoothCapabilities;

    fn to_glib(&self) -> nm_sys::NMBluetoothCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMBluetoothCapabilities> for BluetoothCapabilities {
    fn from_glib(value: nm_sys::NMBluetoothCapabilities) -> BluetoothCapabilities {
        BluetoothCapabilities::from_bits_truncate(value)
    }
}

impl StaticType for BluetoothCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_bluetooth_capabilities_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BluetoothCapabilities {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BluetoothCapabilities {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for BluetoothCapabilities {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
bitflags! {
    pub struct CheckpointCreateFlags: u32 {
        const NONE = 0;
        const DESTROY_ALL = 1;
        const DELETE_NEW_CONNECTIONS = 2;
        const DISCONNECT_NEW_DEVICES = 4;
        const ALLOW_OVERLAPPING = 8;
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for CheckpointCreateFlags {
    type GlibType = nm_sys::NMCheckpointCreateFlags;

    fn to_glib(&self) -> nm_sys::NMCheckpointCreateFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMCheckpointCreateFlags> for CheckpointCreateFlags {
    fn from_glib(value: nm_sys::NMCheckpointCreateFlags) -> CheckpointCreateFlags {
        CheckpointCreateFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
impl StaticType for CheckpointCreateFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_checkpoint_create_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
impl<'a> FromValueOptional<'a> for CheckpointCreateFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
impl<'a> FromValue<'a> for CheckpointCreateFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_4", feature = "dox"))]
impl SetValue for CheckpointCreateFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
bitflags! {
    pub struct ClientInstanceFlags: u32 {
        const NONE = 0;
        const NO_AUTO_FETCH_PERMISSIONS = 1;
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for ClientInstanceFlags {
    type GlibType = nm_sys::NMClientInstanceFlags;

    fn to_glib(&self) -> nm_sys::NMClientInstanceFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMClientInstanceFlags> for ClientInstanceFlags {
    fn from_glib(value: nm_sys::NMClientInstanceFlags) -> ClientInstanceFlags {
        ClientInstanceFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
impl StaticType for ClientInstanceFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_client_instance_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
impl<'a> FromValueOptional<'a> for ClientInstanceFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
impl<'a> FromValue<'a> for ClientInstanceFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_24", feature = "dox"))]
impl SetValue for ClientInstanceFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct ConnectionSerializationFlags: u32 {
        const ALL = 0;
        const NO_SECRETS = 1;
        const ONLY_SECRETS = 2;
        const WITH_SECRETS_AGENT_OWNED = 4;
    }
}

#[doc(hidden)]
impl ToGlib for ConnectionSerializationFlags {
    type GlibType = nm_sys::NMConnectionSerializationFlags;

    fn to_glib(&self) -> nm_sys::NMConnectionSerializationFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMConnectionSerializationFlags> for ConnectionSerializationFlags {
    fn from_glib(value: nm_sys::NMConnectionSerializationFlags) -> ConnectionSerializationFlags {
        ConnectionSerializationFlags::from_bits_truncate(value)
    }
}

impl StaticType for ConnectionSerializationFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_connection_serialization_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ConnectionSerializationFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ConnectionSerializationFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for ConnectionSerializationFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct DeviceCapabilities: u32 {
        const NONE = 0;
        const NM_SUPPORTED = 1;
        const CARRIER_DETECT = 2;
        const IS_SOFTWARE = 4;
        const SRIOV = 8;
    }
}

#[doc(hidden)]
impl ToGlib for DeviceCapabilities {
    type GlibType = nm_sys::NMDeviceCapabilities;

    fn to_glib(&self) -> nm_sys::NMDeviceCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMDeviceCapabilities> for DeviceCapabilities {
    fn from_glib(value: nm_sys::NMDeviceCapabilities) -> DeviceCapabilities {
        DeviceCapabilities::from_bits_truncate(value)
    }
}

impl StaticType for DeviceCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_device_capabilities_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceCapabilities {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceCapabilities {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for DeviceCapabilities {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
bitflags! {
    pub struct DeviceInterfaceFlags: u32 {
        const UP = 1;
        const LOWER_UP = 2;
        const CARRIER = 65536;
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for DeviceInterfaceFlags {
    type GlibType = nm_sys::NMDeviceInterfaceFlags;

    fn to_glib(&self) -> nm_sys::NMDeviceInterfaceFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMDeviceInterfaceFlags> for DeviceInterfaceFlags {
    fn from_glib(value: nm_sys::NMDeviceInterfaceFlags) -> DeviceInterfaceFlags {
        DeviceInterfaceFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl StaticType for DeviceInterfaceFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_device_interface_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl<'a> FromValueOptional<'a> for DeviceInterfaceFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl<'a> FromValue<'a> for DeviceInterfaceFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl SetValue for DeviceInterfaceFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct DeviceModemCapabilities: u32 {
        const NONE = 0;
        const POTS = 1;
        const CDMA_EVDO = 2;
        const GSM_UMTS = 4;
        const LTE = 8;
    }
}

#[doc(hidden)]
impl ToGlib for DeviceModemCapabilities {
    type GlibType = nm_sys::NMDeviceModemCapabilities;

    fn to_glib(&self) -> nm_sys::NMDeviceModemCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMDeviceModemCapabilities> for DeviceModemCapabilities {
    fn from_glib(value: nm_sys::NMDeviceModemCapabilities) -> DeviceModemCapabilities {
        DeviceModemCapabilities::from_bits_truncate(value)
    }
}

impl StaticType for DeviceModemCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_device_modem_capabilities_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceModemCapabilities {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceModemCapabilities {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for DeviceModemCapabilities {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct DeviceWifiCapabilities: u32 {
        const NONE = 0;
        const CIPHER_WEP40 = 1;
        const CIPHER_WEP104 = 2;
        const CIPHER_TKIP = 4;
        const CIPHER_CCMP = 8;
        const WPA = 16;
        const RSN = 32;
        const AP = 64;
        const ADHOC = 128;
        const FREQ_VALID = 256;
        const FREQ_2GHZ = 512;
        const FREQ_5GHZ = 1024;
        const MESH = 4096;
        const IBSS_RSN = 8192;
    }
}

#[doc(hidden)]
impl ToGlib for DeviceWifiCapabilities {
    type GlibType = nm_sys::NMDeviceWifiCapabilities;

    fn to_glib(&self) -> nm_sys::NMDeviceWifiCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMDeviceWifiCapabilities> for DeviceWifiCapabilities {
    fn from_glib(value: nm_sys::NMDeviceWifiCapabilities) -> DeviceWifiCapabilities {
        DeviceWifiCapabilities::from_bits_truncate(value)
    }
}

impl StaticType for DeviceWifiCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_device_wifi_capabilities_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DeviceWifiCapabilities {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DeviceWifiCapabilities {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for DeviceWifiCapabilities {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
bitflags! {
    pub struct DhcpHostnameFlags: u32 {
        const NONE = 0;
        const FQDN_SERV_UPDATE = 1;
        const FQDN_ENCODED = 2;
        const FQDN_NO_UPDATE = 4;
        const FQDN_CLEAR_FLAGS = 8;
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for DhcpHostnameFlags {
    type GlibType = nm_sys::NMDhcpHostnameFlags;

    fn to_glib(&self) -> nm_sys::NMDhcpHostnameFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMDhcpHostnameFlags> for DhcpHostnameFlags {
    fn from_glib(value: nm_sys::NMDhcpHostnameFlags) -> DhcpHostnameFlags {
        DhcpHostnameFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl StaticType for DhcpHostnameFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_dhcp_hostname_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl<'a> FromValueOptional<'a> for DhcpHostnameFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl<'a> FromValue<'a> for DhcpHostnameFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl SetValue for DhcpHostnameFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
bitflags! {
    pub struct IPAddressCmpFlags: u32 {
        const NONE = 0;
        const WITH_ATTRS = 1;
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for IPAddressCmpFlags {
    type GlibType = nm_sys::NMIPAddressCmpFlags;

    fn to_glib(&self) -> nm_sys::NMIPAddressCmpFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMIPAddressCmpFlags> for IPAddressCmpFlags {
    fn from_glib(value: nm_sys::NMIPAddressCmpFlags) -> IPAddressCmpFlags {
        IPAddressCmpFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl StaticType for IPAddressCmpFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_ip_address_cmp_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl<'a> FromValueOptional<'a> for IPAddressCmpFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl<'a> FromValue<'a> for IPAddressCmpFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl SetValue for IPAddressCmpFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
bitflags! {
    pub struct IPRoutingRuleAsStringFlags: u32 {
        const NONE = 0;
        const AF_INET = 1;
        const AF_INET6 = 2;
        const VALIDATE = 4;
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for IPRoutingRuleAsStringFlags {
    type GlibType = nm_sys::NMIPRoutingRuleAsStringFlags;

    fn to_glib(&self) -> nm_sys::NMIPRoutingRuleAsStringFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMIPRoutingRuleAsStringFlags> for IPRoutingRuleAsStringFlags {
    fn from_glib(value: nm_sys::NMIPRoutingRuleAsStringFlags) -> IPRoutingRuleAsStringFlags {
        IPRoutingRuleAsStringFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
impl StaticType for IPRoutingRuleAsStringFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_ip_routing_rule_as_string_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
impl<'a> FromValueOptional<'a> for IPRoutingRuleAsStringFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
impl<'a> FromValue<'a> for IPRoutingRuleAsStringFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
impl SetValue for IPRoutingRuleAsStringFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct IPTunnelFlags: u32 {
        const NONE = 0;
        const IP6_IGN_ENCAP_LIMIT = 1;
        const IP6_USE_ORIG_TCLASS = 2;
        const IP6_USE_ORIG_FLOWLABEL = 4;
        const IP6_MIP6_DEV = 8;
        const IP6_RCV_DSCP_COPY = 16;
        const IP6_USE_ORIG_FWMARK = 32;
    }
}

#[doc(hidden)]
impl ToGlib for IPTunnelFlags {
    type GlibType = nm_sys::NMIPTunnelFlags;

    fn to_glib(&self) -> nm_sys::NMIPTunnelFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMIPTunnelFlags> for IPTunnelFlags {
    fn from_glib(value: nm_sys::NMIPTunnelFlags) -> IPTunnelFlags {
        IPTunnelFlags::from_bits_truncate(value)
    }
}

impl StaticType for IPTunnelFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_ip_tunnel_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IPTunnelFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IPTunnelFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for IPTunnelFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
bitflags! {
    pub struct ManagerReloadFlags: u32 {
        const CONF = 1;
        const DNS_RC = 2;
        const DNS_FULL = 4;
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for ManagerReloadFlags {
    type GlibType = nm_sys::NMManagerReloadFlags;

    fn to_glib(&self) -> nm_sys::NMManagerReloadFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMManagerReloadFlags> for ManagerReloadFlags {
    fn from_glib(value: nm_sys::NMManagerReloadFlags) -> ManagerReloadFlags {
        ManagerReloadFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl StaticType for ManagerReloadFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_manager_reload_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl<'a> FromValueOptional<'a> for ManagerReloadFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl<'a> FromValue<'a> for ManagerReloadFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_22", feature = "dox"))]
impl SetValue for ManagerReloadFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct SecretAgentCapabilities: u32 {
        const NONE = 0;
        const VPN_HINTS = 1;
        const LAST = 1;
    }
}

#[doc(hidden)]
impl ToGlib for SecretAgentCapabilities {
    type GlibType = nm_sys::NMSecretAgentCapabilities;

    fn to_glib(&self) -> nm_sys::NMSecretAgentCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSecretAgentCapabilities> for SecretAgentCapabilities {
    fn from_glib(value: nm_sys::NMSecretAgentCapabilities) -> SecretAgentCapabilities {
        SecretAgentCapabilities::from_bits_truncate(value)
    }
}

impl StaticType for SecretAgentCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_secret_agent_capabilities_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SecretAgentCapabilities {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SecretAgentCapabilities {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for SecretAgentCapabilities {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct SecretAgentGetSecretsFlags: u32 {
        const NONE = 0;
        const ALLOW_INTERACTION = 1;
        const REQUEST_NEW = 2;
        const USER_REQUESTED = 4;
        const WPS_PBC_ACTIVE = 8;
        const ONLY_SYSTEM = 2147483648;
        const NO_ERRORS = 1073741824;
    }
}

#[doc(hidden)]
impl ToGlib for SecretAgentGetSecretsFlags {
    type GlibType = nm_sys::NMSecretAgentGetSecretsFlags;

    fn to_glib(&self) -> nm_sys::NMSecretAgentGetSecretsFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSecretAgentGetSecretsFlags> for SecretAgentGetSecretsFlags {
    fn from_glib(value: nm_sys::NMSecretAgentGetSecretsFlags) -> SecretAgentGetSecretsFlags {
        SecretAgentGetSecretsFlags::from_bits_truncate(value)
    }
}

impl StaticType for SecretAgentGetSecretsFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_secret_agent_get_secrets_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SecretAgentGetSecretsFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SecretAgentGetSecretsFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for SecretAgentGetSecretsFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
bitflags! {
    pub struct Setting8021xAuthFlags: u32 {
        const NONE = 0;
        const TLS_1_0_DISABLE = 1;
        const TLS_1_1_DISABLE = 2;
        const TLS_1_2_DISABLE = 4;
        const ALL = 7;
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for Setting8021xAuthFlags {
    type GlibType = nm_sys::NMSetting8021xAuthFlags;

    fn to_glib(&self) -> nm_sys::NMSetting8021xAuthFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSetting8021xAuthFlags> for Setting8021xAuthFlags {
    fn from_glib(value: nm_sys::NMSetting8021xAuthFlags) -> Setting8021xAuthFlags {
        Setting8021xAuthFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl StaticType for Setting8021xAuthFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_802_1x_auth_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl<'a> FromValueOptional<'a> for Setting8021xAuthFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl<'a> FromValue<'a> for Setting8021xAuthFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_8", feature = "dox"))]
impl SetValue for Setting8021xAuthFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct SettingDcbFlags: u32 {
        const NONE = 0;
        const ENABLE = 1;
        const ADVERTISE = 2;
        const WILLING = 4;
    }
}

#[doc(hidden)]
impl ToGlib for SettingDcbFlags {
    type GlibType = nm_sys::NMSettingDcbFlags;

    fn to_glib(&self) -> nm_sys::NMSettingDcbFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingDcbFlags> for SettingDcbFlags {
    fn from_glib(value: nm_sys::NMSettingDcbFlags) -> SettingDcbFlags {
        SettingDcbFlags::from_bits_truncate(value)
    }
}

impl StaticType for SettingDcbFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_dcb_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingDcbFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingDcbFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for SettingDcbFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct SettingSecretFlags: u32 {
        const NONE = 0;
        const AGENT_OWNED = 1;
        const NOT_SAVED = 2;
        const NOT_REQUIRED = 4;
    }
}

#[doc(hidden)]
impl ToGlib for SettingSecretFlags {
    type GlibType = nm_sys::NMSettingSecretFlags;

    fn to_glib(&self) -> nm_sys::NMSettingSecretFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingSecretFlags> for SettingSecretFlags {
    fn from_glib(value: nm_sys::NMSettingSecretFlags) -> SettingSecretFlags {
        SettingSecretFlags::from_bits_truncate(value)
    }
}

impl StaticType for SettingSecretFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_secret_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SettingSecretFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SettingSecretFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for SettingSecretFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
bitflags! {
    pub struct SettingWiredWakeOnLan: u32 {
        const PHY = 2;
        const UNICAST = 4;
        const MULTICAST = 8;
        const BROADCAST = 16;
        const ARP = 32;
        const MAGIC = 64;
        const DEFAULT = 1;
        const IGNORE = 32768;
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingWiredWakeOnLan {
    type GlibType = nm_sys::NMSettingWiredWakeOnLan;

    fn to_glib(&self) -> nm_sys::NMSettingWiredWakeOnLan {
        self.bits()
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingWiredWakeOnLan> for SettingWiredWakeOnLan {
    fn from_glib(value: nm_sys::NMSettingWiredWakeOnLan) -> SettingWiredWakeOnLan {
        SettingWiredWakeOnLan::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl StaticType for SettingWiredWakeOnLan {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_wired_wake_on_lan_get_type()) }
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingWiredWakeOnLan {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl<'a> FromValue<'a> for SettingWiredWakeOnLan {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_2", feature = "dox"))]
impl SetValue for SettingWiredWakeOnLan {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
bitflags! {
    pub struct SettingWirelessSecurityWpsMethod: u32 {
        const DEFAULT = 0;
        const DISABLED = 1;
        const AUTO = 2;
        const PBC = 4;
        const PIN = 8;
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingWirelessSecurityWpsMethod {
    type GlibType = nm_sys::NMSettingWirelessSecurityWpsMethod;

    fn to_glib(&self) -> nm_sys::NMSettingWirelessSecurityWpsMethod {
        self.bits()
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingWirelessSecurityWpsMethod> for SettingWirelessSecurityWpsMethod {
    fn from_glib(
        value: nm_sys::NMSettingWirelessSecurityWpsMethod,
    ) -> SettingWirelessSecurityWpsMethod {
        SettingWirelessSecurityWpsMethod::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl StaticType for SettingWirelessSecurityWpsMethod {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_wireless_security_wps_method_get_type()) }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingWirelessSecurityWpsMethod {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl<'a> FromValue<'a> for SettingWirelessSecurityWpsMethod {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
impl SetValue for SettingWirelessSecurityWpsMethod {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
bitflags! {
    pub struct SettingWirelessWakeOnWLan: u32 {
        const ANY = 2;
        const DISCONNECT = 4;
        const MAGIC = 8;
        const GTK_REKEY_FAILURE = 16;
        const EAP_IDENTITY_REQUEST = 32;
        const __4WAY_HANDSHAKE = 64;
        const RFKILL_RELEASE = 128;
        const TCP = 256;
        const ALL = 510;
        const DEFAULT = 1;
        const IGNORE = 32768;
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingWirelessWakeOnWLan {
    type GlibType = nm_sys::NMSettingWirelessWakeOnWLan;

    fn to_glib(&self) -> nm_sys::NMSettingWirelessWakeOnWLan {
        self.bits()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingWirelessWakeOnWLan> for SettingWirelessWakeOnWLan {
    fn from_glib(value: nm_sys::NMSettingWirelessWakeOnWLan) -> SettingWirelessWakeOnWLan {
        SettingWirelessWakeOnWLan::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl StaticType for SettingWirelessWakeOnWLan {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_setting_wireless_wake_on_wlan_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingWirelessWakeOnWLan {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValue<'a> for SettingWirelessWakeOnWLan {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl SetValue for SettingWirelessWakeOnWLan {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
bitflags! {
    pub struct SettingsAddConnection2Flags: u32 {
        const NONE = 0;
        const TO_DISK = 1;
        const IN_MEMORY = 2;
        const BLOCK_AUTOCONNECT = 32;
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingsAddConnection2Flags {
    type GlibType = nm_sys::NMSettingsAddConnection2Flags;

    fn to_glib(&self) -> nm_sys::NMSettingsAddConnection2Flags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingsAddConnection2Flags> for SettingsAddConnection2Flags {
    fn from_glib(value: nm_sys::NMSettingsAddConnection2Flags) -> SettingsAddConnection2Flags {
        SettingsAddConnection2Flags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
impl StaticType for SettingsAddConnection2Flags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_settings_add_connection2_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingsAddConnection2Flags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
impl<'a> FromValue<'a> for SettingsAddConnection2Flags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
impl SetValue for SettingsAddConnection2Flags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
bitflags! {
    pub struct SettingsConnectionFlags: u32 {
        const NONE = 0;
        const UNSAVED = 1;
        const NM_GENERATED = 2;
        const VOLATILE = 4;
        const EXTERNAL = 8;
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingsConnectionFlags {
    type GlibType = nm_sys::NMSettingsConnectionFlags;

    fn to_glib(&self) -> nm_sys::NMSettingsConnectionFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingsConnectionFlags> for SettingsConnectionFlags {
    fn from_glib(value: nm_sys::NMSettingsConnectionFlags) -> SettingsConnectionFlags {
        SettingsConnectionFlags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl StaticType for SettingsConnectionFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_settings_connection_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingsConnectionFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValue<'a> for SettingsConnectionFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl SetValue for SettingsConnectionFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
bitflags! {
    pub struct SettingsUpdate2Flags: u32 {
        const NONE = 0;
        const TO_DISK = 1;
        const IN_MEMORY = 2;
        const IN_MEMORY_DETACHED = 4;
        const IN_MEMORY_ONLY = 8;
        const VOLATILE = 16;
        const BLOCK_AUTOCONNECT = 32;
        const NO_REAPPLY = 64;
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SettingsUpdate2Flags {
    type GlibType = nm_sys::NMSettingsUpdate2Flags;

    fn to_glib(&self) -> nm_sys::NMSettingsUpdate2Flags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<nm_sys::NMSettingsUpdate2Flags> for SettingsUpdate2Flags {
    fn from_glib(value: nm_sys::NMSettingsUpdate2Flags) -> SettingsUpdate2Flags {
        SettingsUpdate2Flags::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl StaticType for SettingsUpdate2Flags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_settings_update2_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SettingsUpdate2Flags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl<'a> FromValue<'a> for SettingsUpdate2Flags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
impl SetValue for SettingsUpdate2Flags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct TeamLinkWatcherArpPingFlags: u32 {
        const VALIDATE_ACTIVE = 2;
        const VALIDATE_INACTIVE = 4;
        const SEND_ALWAYS = 8;
    }
}

#[doc(hidden)]
impl ToGlib for TeamLinkWatcherArpPingFlags {
    type GlibType = nm_sys::NMTeamLinkWatcherArpPingFlags;

    fn to_glib(&self) -> nm_sys::NMTeamLinkWatcherArpPingFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMTeamLinkWatcherArpPingFlags> for TeamLinkWatcherArpPingFlags {
    fn from_glib(value: nm_sys::NMTeamLinkWatcherArpPingFlags) -> TeamLinkWatcherArpPingFlags {
        TeamLinkWatcherArpPingFlags::from_bits_truncate(value)
    }
}

impl StaticType for TeamLinkWatcherArpPingFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_team_link_watcher_arp_ping_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TeamLinkWatcherArpPingFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TeamLinkWatcherArpPingFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for TeamLinkWatcherArpPingFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct VlanFlags: u32 {
        const REORDER_HEADERS = 1;
        const GVRP = 2;
        const LOOSE_BINDING = 4;
        const MVRP = 8;
    }
}

#[doc(hidden)]
impl ToGlib for VlanFlags {
    type GlibType = nm_sys::NMVlanFlags;

    fn to_glib(&self) -> nm_sys::NMVlanFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMVlanFlags> for VlanFlags {
    fn from_glib(value: nm_sys::NMVlanFlags) -> VlanFlags {
        VlanFlags::from_bits_truncate(value)
    }
}

impl StaticType for VlanFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_vlan_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VlanFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VlanFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for VlanFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct VpnEditorPluginCapability: u32 {
        const NONE = 0;
        const IMPORT = 1;
        const EXPORT = 2;
        const IPV6 = 4;
    }
}

#[doc(hidden)]
impl ToGlib for VpnEditorPluginCapability {
    type GlibType = nm_sys::NMVpnEditorPluginCapability;

    fn to_glib(&self) -> nm_sys::NMVpnEditorPluginCapability {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NMVpnEditorPluginCapability> for VpnEditorPluginCapability {
    fn from_glib(value: nm_sys::NMVpnEditorPluginCapability) -> VpnEditorPluginCapability {
        VpnEditorPluginCapability::from_bits_truncate(value)
    }
}

impl StaticType for VpnEditorPluginCapability {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_vpn_editor_plugin_capability_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VpnEditorPluginCapability {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VpnEditorPluginCapability {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for VpnEditorPluginCapability {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct _80211ApFlags: u32 {
        const NONE = 0;
        const PRIVACY = 1;
        const WPS = 2;
        const WPS_PBC = 4;
        const WPS_PIN = 8;
    }
}

#[doc(hidden)]
impl ToGlib for _80211ApFlags {
    type GlibType = nm_sys::NM80211ApFlags;

    fn to_glib(&self) -> nm_sys::NM80211ApFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NM80211ApFlags> for _80211ApFlags {
    fn from_glib(value: nm_sys::NM80211ApFlags) -> _80211ApFlags {
        _80211ApFlags::from_bits_truncate(value)
    }
}

impl StaticType for _80211ApFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_802_11_ap_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for _80211ApFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for _80211ApFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for _80211ApFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}

bitflags! {
    pub struct _80211ApSecurityFlags: u32 {
        const NONE = 0;
        const PAIR_WEP40 = 1;
        const PAIR_WEP104 = 2;
        const PAIR_TKIP = 4;
        const PAIR_CCMP = 8;
        const GROUP_WEP40 = 16;
        const GROUP_WEP104 = 32;
        const GROUP_TKIP = 64;
        const GROUP_CCMP = 128;
        const KEY_MGMT_PSK = 256;
        const KEY_MGMT_802_1X = 512;
        const KEY_MGMT_SAE = 1024;
        const KEY_MGMT_OWE = 2048;
        const KEY_MGMT_OWE_TM = 4096;
    }
}

#[doc(hidden)]
impl ToGlib for _80211ApSecurityFlags {
    type GlibType = nm_sys::NM80211ApSecurityFlags;

    fn to_glib(&self) -> nm_sys::NM80211ApSecurityFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<nm_sys::NM80211ApSecurityFlags> for _80211ApSecurityFlags {
    fn from_glib(value: nm_sys::NM80211ApSecurityFlags) -> _80211ApSecurityFlags {
        _80211ApSecurityFlags::from_bits_truncate(value)
    }
}

impl StaticType for _80211ApSecurityFlags {
    fn static_type() -> Type {
        unsafe { from_glib(nm_sys::nm_802_11_ap_security_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for _80211ApSecurityFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for _80211ApSecurityFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
    }
}

impl SetValue for _80211ApSecurityFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
    }
}
